---
title: "Конспект-справочник 'Моделирование на C++'"
output:
  word_document: default
  pdf_document:
    number_sections: yes
    toc: yes
  html_document:
    toc: yes
---

# Введение

 **Цель**: освоение основных принципов объектно-ориентированного проектирования и программирования моделей на языке C++.

**Методика**: обучение на примерах решения практических задач математического и компьютерного моделирования.

**Этапы**: изучение синтаксиса языка, выполнение упражнений, создание и выполнение учебных заданий по моделированию систем из различных предметных областей.

## История, предназначение и перспективы языка

Это слегка скучный, но обязательный раздел для пояснения того, чего следует ожидать на последующих страницах документа. Пожалуйста, прочтите следующий абзац, и вы сразу все поймете. 

Документ посвящен методам моделирования систем. Cо временем смысл понятий "моделирование" или  "симулирование" станет ясен из примеров, в достаточной мере присутствующих в тексте. Это будет совершенно конкретный и практичный документ. В ходе изложения будут рассмотрены способы статистического моделирования, моделирования систем на основе дифференциальных уравнений…. Примеры моделей будут написаны на языке программирования C++, поэтому в начале будет краткое введение в этот язык программирования.

Язык С++, который будет использован в качестве рабочего инструмента в этом документе, представляет собой объектно-ориентированный язык общего назначения, особенно удобный для системного программирования, но предназначенный для промышленной разработки прикладного программного обеспечения в различных областях: научные вычисления, операционные системы, игры и мультимедийные приложения, встраиваемые системы, другие языки программирования, бизнес-приложения, мобильные приложения и т.д.. Существуют реализации языка (компиляторы) для различных целевых процессорных платформ, таких как x86 (Intel и совместимые), PowerPC, Blackfin, MIPS, XScale, ARM или Cortex. 

Разработка языка началась в начале 1980-х годов Бьёрном Страуструпом. Первое издание его книги "Язык программирования C++" вышло в 1985 году. Последнюю на данный момент 4-ю редакцию книги, выпущенную в 2013 году, настоятельно рекомендуем в качестве полного справочника по языку в его современном состоянии. Официальный стандарт, известный как C++98, был принят в 1998 году, спустя 13 лет после выхода в свет книги. В целом история языка оказалась наполненной событиями, информацию о которых вы легко можете найти, и не закончилась в наше время. Сегодня действующим стандартом является C++11, добавивший много существенных возможностей (мы также настоятельно рекомендуем иметь его под рукой), и язык продолжает активно развиваться к следующим запланированным версиям стандарта C++14 и C++17. Значимость и актуальность языка подчеркивается вручением Бьерну Страуструпу в 2013 году диплома и мантии почетного доктора НИУ ИТМО. 

Основные достоинства языка с точки зрения обучения:

* практичность, выражающаяся в распространенности языка, доступности средств разработки, применимости для решения разнообразных практических задач, существования сообщества специалистов, доступности библиотек и приложений, востребованности знающих его специалистов на рынке труда.
* поддержка различных подходов к программированию: процедурного, объектно-ориентированного, обобщенного и функционального.
* относительная простота.
* родственность синтаксиса с множеством языков (C, Java, C#, PHP, JS…)

Основные достоинства языка для моделирования систем:

* высокое быстродействие
* использование на мультипроцессорных и гетерогенных (разнопроцессорных) системах 
* возможность прямого доступа к аппаратным ресурсам
* наличие развитых библиотек упрощающих создание моделируемых систем
* широкая распространенность и переносимость

Универсальность языка позволяет использовать его в задачах моделирования. Более того, при разработке языка его ключевые концепции классов и объектов были заимствованы из языка Simula, специально предназначенного, как явствует из названия, для компьютерного "симулирования".
Помимо разработки самостоятельных программных продуктов C++ может использоваться для расширения функциональности языков программирования Python, R, mathlab, scilab и других, которые могут быть использованы в компьютерном моделировании.

Язык C++ является компилируемым языком (в отличие от интерпретируемых языков и языков с компиляцией времени исполнения). Исходный текст C++ преобразуется компилятором языка в машинный код, исполняемый непосредственно процессорным устройством. Это свойство позволяет писать программы для платформ, не имеющих исполнительных систем времени выполнения или исполняемых библиотек, например, для микропроцессоров, сигнальных или графических процессоров в тех случаях, когда эти платформы позволяют наиболее эффективно решить задачу.

Для C++ существует множество сред разработки, включающих в себя компиляторы языка, которые работают под управлением различных операционных систем: Windows, Linux, OS X (Mac) и др., и создающих исполняемый код как для процессоров, на которых работают сами, так и для внешних целевых процессоров.

Язык является статически типизированным (static typing) т.е. типы переменных определяются на этапе компиляции. Допустимы неявные преобразования типов (слабая типизация или weak typing). Типы переменных задаются явно (explicit typing) исключения С++11.

Объектно-ориентированный подход к созданию программ будет основным при описании языка в данном документе. Преимуществами подхода являются:

* эффективность при работе с множеством однотипных объектов
* безопасность данных
* модульность
* абстрагирование от деталей реализации

Принципы объектно-ориентированного подхода:

* Все переменные в программе являются объектами, где объект - экземпляр класса.
* Класс (объектов) является типом переменных, определяющим как сами данные, входящие в состав переменной, так и операции над ними (процедуры, функции, методы класса).
* Программа строится как взаимодействие объектов путем вызова их методов.
* Классы организованы в иерархию наследования, при которой производные классы наследуют свойства базового класса и расширяют или уточняют его функциональность.

## Термины и определения

Здесь, в начале, приведены основные понятия, необходимые для восприятия дальнейшего материала.

* Целевая платформа (target) - платформа, для которой ведется разработка и на которой исполняется код программы. Пример: микроконтроллер.
* Хост-платформа (host) - платформа на которой ведется разработка. Часто хост-платформа является также целевой. Пример: х86 с ОС Windows (при этом программа может предназначаться для исполнения на микроонтрллере).
* Тип данных - способ хранения, соответствующее ему множество значений/состояний и набор операций, относящихся к данным. Типизация - принадлежность переменных определенным типам данных. Пример: целый тип, булевский тип.
* Статическая типизация (static typing) - язык программирования имеет статическую типизацию если проверка типов осуществляется на этапе компиляции программы. Языки со статической типизацией: ActionScript 3, Ada, C, D, Eiffel, F#, Fortran, Go, Haskell, haXe, JADE, Java, ML, Objective-C, OCaml, Pascal, Seed7, Scala.
* Динамическая типизация (dynamic typing) - язык программирования имеет динамическую типизацию если проверка типов осуществляется на этапе исполнения программы. Языки с динамичекой типизацией: APL, Erlang, Groovy, JavaScript, Lisp, Lua, MATLAB, GNU Octave, Perl, PHP, Pick BASIC, Prolog, Python, R, Ruby, Smalltalk, Tcl
* Класс (class) - составной тип данных, объединяющий данные и операции, относящиеся к этим данным. Переменные класса (типа) называются объектами или экземплярами класса. Пример: класс точек на плоскости.
* Объявление (declaration) - указывает на существование объекта или функции но не приводит к их реализации компилятором. Пример: class Point; (реализация класса не указана)
* Определение (definition) - реализация объекта или функции, приводящая к размещению компилятором памяти для хранения данных и генерированию кода для функций. Определение одновременно является объявлением. Пример: class Point{...реализация...};
* Инициализация (initialization) - присвоение переменной или объекту (экземпляру класса) начального значения.
* Компилятор (compiler) - программа, преобразующая исходный текст на языке программирования в исполняемый код.
* Компоновщик (linker) - программа, собирающая исполняемый код различных модулей в исполняемую программу.
* Байт (byte) - минимальная единица хранения информации, имеющая собственный адрес.


# Основы C++

## Структура программы

Программа на C++ представляет собой набор файлов реализации и заголовочных файлов, содержащих исходные тексты на языке C++ в текстовой, читаемой и редактируемой человеком форме. Заголовочные файлы включаются препроцессором (буквально вставляются как есть в тексовом виде) в файлы реализации или в другие заголовочные файлы директивой \#include. Расширение файла может быть произвольным. Часто для файлов реализации используют расширение \*.cpp и для заголовочных файлов - \*.h. Но могут быть приняты и другие соглашения о наименовании файлов.

В общем случае заголовочных файлах содержатся объявления классов, типов, переменных и функций, в файле реализации эти объявления определяются или используются.

![Alt text](structure.png "Title")
  Рисунок 1. Структура программы.
  
В простой структуре, изображенной на Рисунке 1, предполагается что содержимое заголовочного файла class.h директивой препроцессора \#include целиком включено в файлы main.cpp и class.cpp.

Если исключить из рассмотрения статические и динамические библиотеки, и рассматривать только запускаемые автономные программы, то точкой входа, т.е. началом исполнения программы, будет функция main(). Пример простой программы:

```{r,engine='Rcpp',eval=F}
#include <iostream> //подключаемый заголовочный файл для вывода строки «Hellow World» в conio

// - здесь и ниже обозначает комментарий и при компиляции все, что за ним игнорируется
// int – тип возвращаемого значния (целое)
// main – имя функции 
// () – пустой список параметров
int main () 
{   // начало блока-тела функции
    std::cout << "Hello World!"; // вывод строки в консоль
    return 0; // возврат из функции со значением «0»
    // обратите внимание на символ ';' после каждого оператора
}   // конец блока
```
Функцию main() в отличие от других функций нельзя вызвать из других частей программы. Если у функции main() отсутствует оператор "return", то функция возвращает "0" после завершения исполнения. Для любой другой функции, возвращающей значение, отсутствие оператора возврата вызовет ошибку компиляции. 

Аргументы командной строки могут передаваться в функцию с помощью параметров:

```{r,engine='Rcpp',eval=F}
int main(int argc, char* argv[]) { операторы... }
```
Здесь параметр argc - количество аргументов, argv - указатель на массив строк, содержащих аргументы. Про строки и массивы информация появится чуть позже.

Функция main() является функцией с заранее определенными именем, которой передается управление при старте программы. Программист может создавать свои собственные функции и передавать управление им т.е. вызывать их из других частей собственного кода.

Пример определения (definition) функции:
```{r,engine='Rcpp',eval=F}
// double – тип возвращаемого значния (вещественное двойной точности)
// sinus – имя функции 
// double x - тип и имя аргумента функции
double sinus(double x) 
{ 
    ... // операторы вычисления синуса
    return y; // возврат результата
}
```
Операторы завершаются символом ';'. Просто символ ';' означает пустой оператор. 

Обратите внимание на отступы в тексте. Они не обязательны, можно все написать в строчку, разделяя операторы точкой с запятой. Строгих требований к форматированию текста нет. Допустимы множественные пробелы, знаки табуляции, переходы на новую строку везде между отдельными словами (token) исходного текста. Отступы содержательного значения, как в Python, не имеют и используются для форматирования текста так чтобы он выглядел понятно. Правила форматирования задают так называемые кодовые стандарты, написанные для их соблюдения программистами, участвующими в разработке кода.



Функция должна быть объявлена до первого использования.Пример:
```{r,engine='Rcpp',eval=F}
#include <iostream> 

// Объявление функции sinus() до своего первого использования. 
// В этом месте объявление может быть заменено определением (см. конец примера).
double sinus(double x); 

int main () 
{ 
    std::cout << "sin="<<sinus(3.14); // вывод вначале строки, затем результата работы функции sinus() в консоль
    return 0; // возврат из функции со значением «0»
}

// определение (тела) функции sinus()
double sinus(double x) 
{ 
    // вычисление возвращаемого значения по первым членам ряда Тейлора
    return x - x*x*x/6; 
}
```
Для того, чтобы функцию можно было использовать в разных исходных файлах, объявление переносят в заголовочный файл *.h, который затем включается директивой #include в каждый из файлов реализации *.cpp, в которых функция будет вызываться.


Операторы языка группируются в блоки, начало и конец которых отмечается фигурными скобками. Тело функции, в том числе функции main(), является таким блоком. Тело функции - не единственный пример использования блоков кода, блоки используются также и там, где необходимы несколько операторов:

```{r,engine='Rcpp',eval=F}
int func()
{
    if(x>0)
        a;// оператор a. Требуется выполнение только одного оператора

    if(y>0)
    {
        a;// оператор a. Требуется выполнение нескольких операторов
        b;// оператор b.
    }
}
```

При сборке программы компилятор игнорирует комментарии, которые могут быть однострочными "//..." или многострочными "/* ... */". 
```{r,engine='Rcpp',eval=F}
// Однострочный комментарий до конца строки

/* Многострочный комментарий 
   до закрывающей этот комментарий звездочки
*/
```

Для создания первой программы и проверки процедуры ее сборки можно воспользоваться любой бесплатной интегрированной средой разработки, доступной для вашей операционной системы.Примеры таких интегрированных сред разработки: Visual Studio Express для Windows (Desktop); Qt Creator; Code::Blocks; Eclips CDT; NetBeans. 

В качестве самой простой, нетребовательной к ресурсам персонального компьютера, бесплатной и свободной от юридических ограничений использования, доступной на  Mac, Win, и Lin машинах предлагаем Code::Blocks (www.codeblocks.org). 

Как показывает опыт преподавания MOOC (massive online open courses) большая часть студентов (~30%) бросает учебу на этапе установки и настройки среды разработки. Не бросайте, установить и запустить Code::Blocks очень просто.

Примеры для этого документа созданы в среде Code::Blocks. После установки и запуска этой среды разработки нужно выбрать меню File->New->Project... дальше выбрать иконку "Console application", язык C++, дать латиницей название для нового проекта и и путь к файлам, в котором будет автоматически создан исходный файл main.cpp, содержащий функцию main(). В других средах проекты создаются также очень легко и все подробности описаны в прилагаемой к ним документации.

Упражнение: Соберите и запустите программу. Бегло изучите структуру меню интегрированной среды.

## Процесс сборки программы

Программа - совокупность единиц трансляции - отдельных исходных файлов со всеми своими включениями. Процесс сборки программы представляет собой многоэтапное преобразование исходного кода программы, написанной на языке C++, в машинно-зависимый исполняемый код. В соответствии с принципом раздельной компиляции каждый файл исходного текста (translation unit) компилируется в объектный код отдельно от других исходных файлов.
Этапами сборки программы являются: 
1. препроцессинг (обработка исходных текстов) 
2. компиляция (преобразование единиц трансляции, предобработанных исходных файлов, в машинный код) 
3. компоновка (или линковка - окончательная сборка исполняемого модуля из единиц трансляции)


![Alt text](stages.png "Title")
  Рисунок 2. Этапы сборки программы
  
В результате выполнения этих этапов компиляции будет создан файл с исполняемым кодом, например, EXE-файл приложения. Исполняемый код программы исполняется непосредственно процессором целевой платформы. В результате сборки программы на С++ можно создать исполняемые файлы различных типов. Например, статические библиотеки (static library) – код, который подключается во время компиляции компоновщиком и используется в другой программе; динамические библиотеки (dynamic library) то же самое, только библиотека подключается к исполняемой программе во время исполнения, т.е. на лету, динамически; и, наконец, собственно исполняемый код.

## Исполнение и отладка

Разработка программы и ее выполнение – это два разных процесса, несмотря на то, что в современных средах разработки они тесно интегрированы. Эти процессы могут выполняться на разных машинах как, например, это происходит при разработке приложений для мобильных телефонов. При запуске программы возможно подключение к ней отладчика, позволяющего останавливать программу в точках остановки (breakpoint), считывать значения ячеек памяти и переменных.

![Alt text](environment.png "Title")
  Рисунок 3. Среда разработки


## Препроцессор

Перед началом компиляции исходные тексты программы обрабатываются препроцессором. Для управления его работой используются директивы, которые предваряются символом \#. Примеры использования препроцессора:

```{r,engine='Rcpp',eval=F}
#include <iostream>      // Включить заголовок из из стандартных директориев
#include "header1.h"     // Включить заголовок из текущего директория
#include "inc/header2.h" // Включить заголовок из поддиректория inc текущего директория

#define PI 3.14          // Заменить PI на текст "3.14" везде ниже по тексту
#undef PI                // Удалить определение и ниже по тексту больше не заменять PI на "3.14".

#define sum(a,b) a+b     // Заменить sum(1,2) на 1+2
#define E \
  любой текст            // Замена E на "любой текст" и продолжение директивы на следующую строку

#if defined(X)           // Условная компиляция (то же самое что #ifdef X)
#else                    // альтернативная ветка (#ifndef X or #if !defined(X))
#endif                   // Конец блока условной компиляции #if, #ifdef

#if X>200                // Сравнение с константой
int table[X];            // Использование в коде при определении переменной
#endif                   // Конец блока условной компиляции #if, #ifdef
```

Мы не будем использовать препроцессор активно, но он необходим как минимум для решения двух задач: 
1) для включения заголовочного файла:
```{r,engine='Rcpp',eval=F}
#include "header1.h"     // Включить заголовок из текущего директория
```
2) и для проверки того, что заголовочный файл не будет включен многократно. Здесь небольшое пояснение: одни заголовочные файлы могут включать в себя другие и в случае если несколько из них включают один и тот же файл, то при сборке проекта возникнет ошибка повторного объявления. Например, если header1.h и header2.h включают common.h, а программа включает оба заголовочных файла как в этом примере:
```{r,engine='Rcpp',eval=F}
#include "header1.h" 
#include "header2.h" 
int main () 
{ 
```
то common.h окажется включенным в модуль с функцией main() дважды. Чтобы этого избежать используют следующую конструкцию:
```{r,engine='Rcpp',eval=F}
#ifndef COMMON_H // если переменная COMMON_H не определена то используем все что ниже до соответствующего #endif
#define COMMON_H // определяем переменную

// здесь все объявления файла common.h

#endif // COMMON_H
```
Блоки \#if...\#endif, \#ifdef...\#endif, \#ifndef...\#endif могут быть вложенными.



## Объектно-ориентированный подход и начало практической работы

Начнем с определений. Терминология этого документа умышленно немного сужена с целью сформировать понимание концепции объектно-ориентированного подхода в программировании, являющегося основным подходом языка C++, и избежать терминологического наследства процедурных языков, в частности C, расширением которого изначально был C++ (он даже был назван вначале C с классами). 

Все что в процедурных языках называется "переменная" в C++ с позиций ООП правильнее называть экземплярами класса или *объектами*. Переменная - это именованная область памяти. Объект (object)  - это экземпляр (instance)  определенного класса (object class) объектов, типа.  

Все объекты в C++ имеют свой *класс* или тип объектов. Класс определяет не только данные объектов класса, но и операции, которые можно производить с объектом. Например, класс комплексных чисел должен будет содержать для всех своих объектов данные о действительной и мнимой составляющих, а также операции умножения, деления, сложения, вычитания и модуля. Такие операции называются методами класса, а данные - данными класса.

Еще раз, есть типы - классы, и есть их экземрпляры - объекты.

Классы, необходимые для работы программы, создает программист, но язык сразу предоставляет *фундаментальные типы данных*, такие как *int*, *double*, *bool*, *char*.

Объектно-ориентированный подход в программировании строится на следующих принципах:
* *Инкапсуляция* - разделение интерфейсов использования класса и его внтренней реализации.
* *Наследование* - возможность расширения классов путем создания классов наследников, включающих в себя данные и методы классов предшественников, и привносящих  в них новые данные и/или методы.
* *Полиморфизм* - изменение функциональности методов с одним и тем-же именем в зависимости от конкретного объекта, для которого этот метод вызывается.
* *Композиция* - конструирование нового класса, состоящего из других классов.

Возвращаясь к практике, для того чтобы приступить к работе необходимо создать новый класс, объект этого класса и начать этот объект использовать в разрабатываемой программе.

Файл "main.cpp":
```{r,engine='Rcpp',eval=F}
#include "example_01.h" // В этом файле дано определение класса
int main () 
{ 
    A a;         // Создание объекта с именем "a" класса "A".
    a.print();   // Использование объекта - вызов извне класса метода print() для объекта "a".
}
```

Файл "example_01.h":
```{r,engine='Rcpp',eval=F}
// Препроцессорная защита от повторного включения содержимого этого файла
#ifndef EXAMPLE_01_H 
#define EXAMPLE_01_H 

// Заголовочный файл стандартной библиотеки для консольного вывода
#include <iostream> 

// Определение класса "A"
class A
{
    double x, y; // данные члены класса. По умолчанию недоступны извне класса
public: //позволяет использовать извне класса методы и данные объявленные после этого модификатора доступа
    // Определение метода класса print()
    void print(){
      // Вывод в консоль средствами стандартной библиотеки
      std::cout << "Hello world!" << std::endl;
    }
};

#endif // EXAMPLE_01_H
```

## Объявления и определения

Еще немного очень важной терминологии: 
* *Объявление* (declaration) объявляет о существовании имени (идентификатора) и его типа или атрибутов. 
* *Определение* (definition) - объявление, которое дополнительно обеспечивает конкретную реализацию для данного идентификатора, заключающуюся в выделении памяти для объекта, соответствующей идентификатору, и возможно, инициализации этой памяти. 

Объявлений может быть много. Главное, чтобы они не противоречили друг другу. В пределах одной единицы трансляции допустимо только одно определение (One Definition Rule или ODR). 

Примеры объявлений (из стандарта):
```{r,engine='Rcpp',eval=F}
extern int a;         // объявление 'a'. Ключевое слово extern говорит о том, что определение дано в другом месте
extern const int c;   // объявление 'c'. Значение константы не указано. Константа не инициализирована благодаря 'extern'.
int f(int);           // объявление 'f'. Объявление функции. Тело функции, ее реализация, отсутствует.
class S;              // объявление 'S'. Объявление класса "S". Содержание класса отсутствует.
typedef int Int;      // объявление 'Int'. Объявление синонима типа. 
using N::d;           // объявление некого 'd' из пространства имен 'N'.
```
Объявления только создают новое имя но не сопостовляют его с конкретной реализацией. В отличие от объявления, определение создает соответствие имени и его воплощения. Примеры взяты также из стандарта:
```{r,engine='Rcpp',eval=F}
int a;                        // определение 'a' типа int
extern const int c = 1;       // определение константы 'c' с конкретным занчением '1' и типом int
int f(int x) { return x+a; }  // определение функции 'f' и параметра 'x'
class S { int a; int b; };    // определение класса 'S' и его членов 'S::a' и 'S::b'
class X {                     // определение 'X'
    int x;                    // определение члена 'x'
    static int y;             // обявление статического члена 'y'. Для того чтобы оно стало определением статический член должен быть проинициализирован. Инициализация статических членов делается вне класса. О статических членах будет отдельный рассказ.
    X(): x(0) { }             // определение конструктора 'X'. Что такое конструктор узнаете позже.
};
int X::y = 1;                 // определение статического члена кдасса 'X::y'
enum { up, down };            // определение энумераторов перечисления 'up' и 'down' (о перечислениях также будет рассказ ниже)
namespace N { int d; }        // определение пространства имен 'N' и объекта в нем 'N::d'
namespace N1 = N;             // определение пространства имен 'N1' как синонима 'N'. Такая конструкция согласно стандарту считается определением потому что новое имя N1 благодаря ей имеет вполне законченный смысл.
X anX;                        // определение объекта 'anX' класса 'X'
```

Язык С++ изначально обладает набором *фундаментальных типов данных*, иначе именуемых встроенными типами, и не требующих определения пользователем (программистом, который их использует). Определение объектов фундаментальныхъ типов, часто называемых переменными, происходит указанием имени объекта после указания типа. Пример:
```{r,engine='Rcpp',eval=F}
int x;
```

### Целые (integer) фундаментальные типы данных с примером определения объекта (переменной):
```{r,engine='Rcpp',eval=F}
int main () 
{ 
    // char может быть знаковым (signed) или беззнаковым (unsigned) в зависимости от реализации компилятора
    char x; 
    // следующие типы могут принимать отрицательные значения т.е. являются знаковыми (signed)
    short int y;      // Также можно писать просто "short y;"
    int z;            // 
    long int v;       // Эквивалентно "long v;"
    long long int w;  // Эквивалентно "long long w;"
}
```
Перечисленные выше типы отличаются числом бит, отводимых для хранения числа. Стандартом гарантируется неравенство  
sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)
где sizeof() - функция вычисления размера в байтах, необходимого для хранения объекта указанног в ее параметрах типа. Также функцию можно использовать для вычисления реального числа байт, отведенных для хранения конкретного объекта, например sizeof(z) выведет число байт, занимаемых "z".

**int** имеет "естественный размер определяемый архитектурой процессора" и в 32-битных системах как правило составит 4 байта.

Для любого из перечисленных целых типов может быть явно указан признак знаковости или беззнаковости - signed или unsigned. Пример:
```{r,engine='Rcpp',eval=F}
int main () 
{ 
    signed char x;         // Теперь char точно  со знаком и может принимать отрицательные значения
    unsigned short y;      // Беззнаковый short
}
```

Упражнение: найти размер целых фундаментальных типов в вашей системе. Для этого взять пример выше и вместо строки "Hello World" вывести размер:
```{r,engine='Rcpp',eval=F}
std::cout << sizeof(char) << std::endl;
```

### Логические (булевские) фундаментальные типы данных с примером определения объекта:
```{r,engine='Rcpp',eval=F}
bool f;
```
Целые (integer) и булевские (boolean) типы типы совместно называются целочисленными (integral types).


### Вещественные фундаментальные типы данных с примером определения объекта:
```{r,engine='Rcpp',eval=F}
float p;
double q;
long double r;
```
Вещественные и целочисленные типы совместно называются арифметическими.

### Символьные типы:
```{r,engine='Rcpp',eval=F}
char    // то же самое, что и целый char выше. Используется для хранения любого из символов основной кодировки
wchar_t // Для хранения любого из символов расширенной кодировки (в основе использует char16_t или char32_t)
```

Исследовать особенности реализации фундаментальных арифметических типов на вашей платформе можно с помощью sizeof() или стандартной библиотеки std:numeric\_limits, вызывая ее методы:
```{r,engine='Rcpp',eval=F}
//std - пространство имен стандартной библиотеки
//numeric_limits - шаблон класса реализующего нужные методы. О шаблонах будет информация ниже.
//<char> - параметр шаблона класса, имя арифметического типа для анализа
std::numeric_limits<char>::func()
```

Пример использования библиотеки:
```{r,engine='Rcpp',eval=F}
#include <iostream> //подключаемый заголовочный файл для вывода в conio
#include <limits>   //функции стандартной библиотеки std::numeric_limits

using namespace std; //использование пространства имен std

int main () {
    cout << "sizeof="<< sizeof(char) << endl;                     // размер в байтах
    cout << "min="   << std::numeric_limits<char>::min() << endl; // минимальное значение
    cout << "max="   << std::numeric_limits<char>::max() << endl; // максимальное значение
    cout << "bits="  << std::numeric_limits<char>::digits << endl;// число значащих бит (исключая знаковый и экспоненту для вещественных чисел)
    return 0;
}
```

###  Операции с фундаментальными типами
Класс объекта характеризуется не только данными, но и операциями, которые можно производить с ними. Для арифметических типов в языке определены операции умножения, деления, сложения, вычитания и другие операции. Соответствие типа и доступных операций сведено в таблице

Операция Описание                                                                  Целые (int)     Вещественные (double)     Булевские (bool) 
-------- --------------------------------------------------                       -------------   -----------------------   ------------------
x++      прибавление 1 к **x** (постфиксный)                                      +                 -                         -  
x--      вычетание 1 из **x**                                                     +                 -                         -  
++x      прибавление 1 к **x** (префиксный)                                       +                 -                         -  
--x      вычетание 1 из **x**                                                     +                 -                         -  
-x       унарный минус                                                            +                 +                         -  
+x       унарный плюс                                                             +                 +                         -  
\         
x * y    умножение                                                                +                 +                         -  
x / y    деление (с округлением целых вниз)                                       +                 +                         -  
x % y    деление по модулю (сохраняется знак **x**)                               +                 -                         -  
x + y    сложение                                                                 +                 +                         -  
x - y    вычитание                                                                +                 +                         -  
\         
x << y   побитовый сдвиг **x** на **y** бит влево **(x * pow(2, y))**             +                 -                         -  
x >> y   побитовый сдвиг **x** на **y** бит вправо**(x / pow(2, y))**             +                 -                         -  
\         
x < y    логическое меньше                                                        +                 +                         -  
x <= y   меньше или равно                                                         +                 +                         -  
x > y    больше                                                                   +                 +                         -  
x >= y   больше или равно                                                         +                 +                         -  
x == y   равно                                                                    +                 +                         +  
x != y   не равно                                                                 +                 +                         +  
\         
x & y    побитовое "и"                                                            +                 -                         -  
x ^ y    исключающее "или"                                                        +                 -                         -  
x | y    побитовое "или"                                                          +                 -                         -  
~x       побитовая инверсия x                                                     +                 -                         +  
\         
!x       логическое отрицание                                                     +                 -                         +  
x && y   логическое "и"                                                           +                 -                         +  
x || y   логическое "или"                                                         +                 -                         +  
\         
x = y    присвоение                                                               +                 +                         +  
x += y   операция с присвоением **x = x + y**, также -= *= /= <<= >>= &= |= ^=    см. соотв. 
                                                                                  операцию     
---------------------------------------------                                     -----------     -------------------   ---------------------

Идентификатор (имя) объекта никаким образом не определяет его тип (класс). Идентификатором может быть последовательность букв латинского алфавита, цифр и символа "_". Идентификаторы не могут начинаться с цифры. Идентификатор не может совпадать с зарезервированными ключевыми словами. Ключевые слова C++ (сразу море полезной но не обязательно понятной информации в одном месте; всему будет объяснение позже):

```{r,engine='Rcpp',eval=F}
alignas     // директива выравнивания данных по границам в байтах
alignof     // возвращает значение границы выравнивания
and         // альтернатива логическому И - "&&"
and_eq      // альтернатива побитовому И с присваиванием "&="
asm         // декларация встраиваемого ассемблерного блока
auto        // начиная с С++11 обозначает неявное определение типа по контексту переменной
bitand      // альтернатива побитовому И - "&"
bitor       // альтернатива логическому ИЛИ - "|"
bool        // булевский фундаментальный тип
break       // выход из внутреннего цикла или оператора switch
case        // ветвь оператора switch
catch       // конец блока обработки исключений
char        // символьный тип
char16_t    // символьный тип в кодировке UTF-16
char32_t    // символьный тип в кодировке UTF-32
class       // декларация класса
compl       // альтернатива побитовому дополнению (унарному НЕТ) - "~"
const       // неизменямый (кнстантный) тип
constexpr   // значение функции или переменной может быть вычислено во время компиляции
const_cast  // преобразование типов с различными const-volatile спецификаторами
continue    // пропуск оставшегося для исполнения тела внутреннего цикла
decltype    // определение типа выражения
default     // ветвь по умолчанию в операторе switch 
            //  или в С++11 указание явной инструкции созлдания конструкторов
delete      // удаление объектов
do          // цикл do-while
double      // тип чисел с плавающей точкой двойной точности
dynamic_cast// преобразование типов в пределах иерархии наследования
else        // альтернативная ветвь оператора if
enum        // декларация перечисляемого типа
explicit    // запрет неявных преобразований в конструкторах инициализации и при копировании
export      // deprecated, запрет разворачивания шаблонов inline
extern      // внешняя декларация
false       // булевский литерал "ложь"
float       // тип чисел с плавающей точкой одинарной точности 
for         // цикл for
friend      // спецификатор, разрешающий доступ к закрытым и защищенным полям и методам извне класса
goto        // безусловный переход управления
if          // оператор условия
inline      // использование кода функции без инструкции вызова
int         // целочисленный тип
long        // большой целочисленный тип
mutable     // изменяемый член константного класса
namespace   // пространство имен
new         // динамическое создание и инициализация объектов
noexcept    // проверка или декларация возможности исключений 
not         // альтернатива логическому НЕТ - "!"
not_eq      // альтернатива логическому НЕТ с присваиванием - "!="
nullptr     // литерал, означающий нулевой указатель
operator    // перегруженный оператор
or          // альтернатива логическому ИЛИ - "||"
or_eq       // альтернатива логическому ИЛИ с присваиванием - "|="
private     // спецификатор закрытого доступа к полям и методам или видимости при наследовании
protected   // спецификатор защищенного доступа к полям и методам или видимости при наследовании
public      // спецификатор публичного доступа к полям и методам или видимости при наследовании
register    // рекомендация компилятору для размещения переменной в регистре
reinterpret_cast // преобразование типов методом изменения интерпретации бинарных данных
return      // возврат из функции
short       // короткий целочисленный тип
signed      // целочисленный тип со знаком
sizeof      // размер переменной или типа в байтах
static      // поле класса, общее для всех объектов. Декларация статической переменной.
static_assert// проверка выражения времени компиляции
static_cast // преобразование типов времени компиляции
struct      // декларация структуры
switch      // оператор выбора
template    // декларация шаблона класса или функции
this        // указатель на объект класса, из которого был произведен вызов метода
thread_local// декларация потоковой переменной
throw       // сигнализация исключения
true        // булевский литерал "истина"
try         // начало блока обработки исключений
typedef     // создание синонима для имени типа
typeid      // возвращает идентификацию типа переменной
typename    // альтернатива ключевому слову class в шаблонах
union       // декларация союза
unsigned    // целочисленный тип без знака
using       // выбор пространства имен; создание синонима для имени типа
virtual     // методы класса, которые могут быть переопределены при наследовании
void        // функция не возвращает значения
volatile    // изменяемый тип объекта, могут быть отключены некоторые оптимизации
wchar_t     // символьный тип для символов, занимающих больше одного байта
while       // цикл while и do-while
xor         // альтернатива побитовому исключающему ИЛИ - "^"
xor_eq      // альтернатива побитовому исключающему ИЛИ - "^="
```

В дополнение к ключевым словам есть два идентификатора, которые имеют значение в определенном контексте, но вне его могут использоваться как идентификаторы объектов.
```{r,engine='Rcpp',eval=F}
override - в производном классе указывает на то, что виртуальная функция переопределена
final - в базовом классе указывает на то, что виртуальная функция не может быт переопределена
```

C++ чувствителен к регистру. Это означает, что идентификаторы, написанные строчными и прописными буквами - разные идентификаторы.

Идентификаторы, содержащие двойное подчеркивание __ или начинающиеся с подчеркивания и заглавной буквы зарезервированы и не должны использоваться как идентификаторы. Все имена, начинающиеся с подчеркивания также зарезервированы для использования в глобальном пространстве имен, но могут использоваться в пользовательском пространстве имен, например, в качестве имен полей класса и т.д.

### Инициализация объекта

*Приведение типа* - преобразование одного типа в другой
*Неявное приведение типов* - преобразование типа без явного указания в тексте программы, к какому типу оно осуществляется. Пример:
```{r,engine='Rcpp',eval=F}
double pi=3.14;
int x=pi; // вещественное число неявно преобразуется в целое
```
*Явное приведение типов* - преобразование типа с явным указанием результирующего типа. Пример:
```{r,engine='Rcpp',eval=F}
double pi=3.14;
int x=static_cast<int>(pi); // вариант №1 (основной). Также dynamic_cast, reinterpret_cast, const_cast которые будут упомянуты ниже
int x=int(pi);              // вариант №2 (без названия)
int x=(int)pi;              // вариант №3 (в стиле С)
```

Существует множество способов определить объект класса или переменную фундаментального типа проинициализировав ее *литералом* (фиксированным значением определенного типа, заданным в исходном тексте программы), или другим объектом данного класса или класса, который может быть *неявно* *приведен* к данному классу.

Можно даже определить объект, оставив его неинициализированным:
```{r,engine='Rcpp',eval=F}
int x01;        // неинициализированный объект (переменная)
```
Во время исполнения объект **x01** будет хранить случайные данные, случайно находящиеся в оперативной памяти в момент его создания. Это приемлемо, если **x01** в дальнейшем будет присвоено новое значение. Присвоить нужное значение сразу при определении объекта можно следующими многочисленными способами:
```{r,engine='Rcpp',eval=F}
int x02{};      // инициализация по умолчанию (значением 0)
int x03=int();  // 
int x04=int{};  //
int x05=10;     // инициализация литералом (значением 10)
int x06(10);
int x07{10};    
int x08=int(10);
int x09=int{10};
int x10=x02;    // инициализация копированием (объектом x02)
int x11(x02);
int x12{x02};
int x13={x02};
```
Предпочтительным вариантом инициализации является вариант с использованием фигурных скобок {}.


### Литералы
*Литерал* - фиксированное значение определенного типа, заданное в исходном тексте программы (в отличие от констант, являющихся неизменяемым объектами, часто инициализированными все теми же литералами).

#### Числовые литералы
Числовые литералы представляют собой собственно вещественные или целые числа, записанные в исходном тексте программы. Целые могут быть представлены в разных системах счисления:
```{r,engine='Rcpp',eval=F}
222                     // десятичное число
0xDE,0XDE               // шестнадцатеричное число
0336                    // восьмеричное число
0b11011110, 0B11011110  // бинарное число
```
Целые числовые литералы могут дополняться суффиксами, определяющими их длину, знаковость или то и другое вместе:
'U' или 'u' - суффикс знака означает, что литерал беззнаковый
'L' или 'l' - суффикс длины означает, что литерал имеет тип long
'LL' или 'll' - суффикс длины означает, что литерал имеет тип long long
Пример:
```{r,engine='Rcpp',eval=F}
222UL // десятичное беззнаковое число unsigned long int
```
Вещественные литералы отличает десятичный разделитель '.' в числе, наличие десятичной экспоненты 'e' или 'E', или и разделитель и  экспонента. Примеры вещественных литералов, перечисленные через запятую:
```{r,engine='Rcpp',eval=F}
3.14              // целая и дробная части, разделенные '.'
2e+6              // 2 миллиона с символом экспоненты 'e' и знаком '+'
2E+6              // 2 миллиона с символом экспоненты 'E' и знаком '+'
2E6               // 2 миллиона с символом экспоненты 'E'
2e-3              // 0.002 с символом экспоненты 'e' и знаком '-'
2.99792458e+8     // скорость света, м/с
6.626e-34         // постоянная планка, Дж*с
.25               // четвертинка, целая часть не приведена
33.               // 33, дробная часть не приведена
```
Вещественный литерал без суффикса имеет тип double. Суффикс f или F означает тип float, l или L - long double.

#### Символьные литералы
Символьные литералы используются для определения отдельных символов текста. Для обозначения символа используются одинарные кавычки и в случае использования расширенной кодировки один из префиксов 'u', 'U' или 'L'. Примеры:
```{r,engine='Rcpp',eval=F}
'w'  // символ, тип char
L'w' // символ wchar_t (UTF-1 ISO 10646)
u'w' // символ char16_t (UCS-2 ISO 10646)
U'w' // символ char32_t (UCS-4 ISO 10646)
```
Ряд символов, в частности непечатываемых, задается *управляющей последовательностью*, начинающейся с обратной черты '\n' - перевод строки (LF), '\r' - возврат каретки (CR), '\t' - табуляция, '\'' - кавычка.

#### Строковые литералы
Строковые литералы определяют строки текста и обозначены двойными кавычками:
```{r,engine='Rcpp',eval=F}
"hello world"   // строка символов типа char
L"hello world"  // строка символов типа wchar_t (UTF-1 ISO 10646)
u"hello world"  // строка символов типа char16_t (UCS-2 ISO 10646)
U"hello world"  // строка символов типа char32_t (UCS-4 ISO 10646)
u8"hello world" // строка символов типа char (UTF-8)
```
В сочетании с префиксами кодировки или без них может использоваться префикс 'R', означающий "raw string" - буквальную строку без управляющих последовательностей.
```{r,engine='Rcpp',eval=F}
u8R'(symbols\t ")'  // эквивалентно строке: symbols\t "
```
#### Пользовательские литералы
Создатель своей программы может создать свои собственные литералы с помощью несколько неожиданной, но вполне работоспособной конструкции.

```{r,engine='Rcpp',eval=F}
constexpr double operator"" _km(long double x)  { return 1E3*x; }
constexpr double operator"" _cm(long double x)  { return 1E-2*x; }
constexpr double operator"" _mm(long double x)  { return 1E-3*x; }

double x = 25.0_cm; // 0.25 - длина в метрах
```
Необязательный спецификатор "constexpr" говорит о том, что выражение должно быть вычислено на этапе компиляции. Т.е компилятор производит все необходимые вычисления и в объектный код вставляет результат этих вычислений. При исполнении программы этот уже готовый результат только используется.

Параметром такого литерала может выступать простой литерал следующих типов (в примере тело оператора заменено бессодержательным return):
```{r,engine='Rcpp',eval=F}
constexpr double operator"" _cm(long double x)            { return 0.; } // 1
constexpr double operator"" _cm(unsigned long long x)     { return 0.; } // 2
constexpr double operator"" _cm(const char* x, size_t)    { return 0.; } // 3
constexpr double operator"" _cm(const char16_t* x, size_t){ return 0.; } // 4
constexpr double operator"" _cm(const char32_t* x, size_t){ return 0.; } // 5
constexpr double operator"" _cm(const wchar_t* x, size_t) { return 0.; } // 6
constexpr double operator"" _cm(const char* x)            { return 0.; } // 7
constexpr double operator"" _cm(char x)                   { return 0.; } // 8

double x1 = 25.0_cm;      // вызывается оператор №1 - long double x
double x2 = 25_cm;        // вызывается оператор №2 - unsigned long long x
double x3 = "25"_cm;      // вызывается оператор №3 - const char* x, size_t
double x4 = u"25"_cm;     // вызывается оператор №4 - const char16_t* x, size_t
double x5 = U"25"_cm;     // вызывается оператор №5 - const char32_t* x, size_t
double x6 = L"25"_cm;     // вызывается оператор №6 - const wchar_t* x, size_t
double x7 = u8R"(25)"_cm; // вызывается оператор №7 - const char* x
double x8 = '2'_cm;       // вызывается оператор №8 - char x

```
Тип возвращаемого значения может быть любым. Суффикс литерала не обязан начинаться с подчеркивания, однако литералы без подчеркивания зарезервированы для будущих возможностей стандарта и их использование нежелательно.

#### Булевские литералы
Литералы типа bool:
```{r,engine='Rcpp',eval=F}
true, false
```
Кстати, не пишите конструкции вида 
```{r,engine='Rcpp',eval=F}
if(x==true)
  ...
```
Если 'x' имеет значение true, то условие 'x==true' не добавляет смысла. Достаточно написать так:
```{r,engine='Rcpp',eval=F}
if(x)
  ...
```

#### Литералы-объекты
Литерал может быть составным и состоять из нескольких простых литералов:
```{r,engine='Rcpp',eval=F}
class Point{
    int _x,_y;
public:
    constexpr Point(int x, int y): _x{x},_y{y}{} // constexpr конструктор
};

Point p={0,0};
```
Для этого конструктор должен быть объявлен constexpr

#### Литерал-указатель
Литерал, означающий указатель с нулевым значением:
```{r,engine='Rcpp',eval=F}
nullptr // нулевой указатель
```


TODO:
Если тип объекта может быть определен компилятором из типа выражения, которым он инициализирован, может использоваться тип 'auto'. Примеры:
```{r,engine='Rcpp',eval=F}
int x{5};
float y{1.0F};
auto z{x * y}; // auto -> float
auto f = int (*)(){return 0;}; // auto -> int f(){ return 0;} ???
auto g = [](){return 0;};
```

TODO: упражнения
функция вычисления квадратноо корня вещественного аргумента
функция вычисления степени

TODO: declspec

TODO: constexpr


## Производные  типы
Выше были рассмотрены фундаментальные (встроенные) типы данных а также составные типы. Язык предоставляет пользователю производные типы данных, такие как указатели, ссылки, и константы.

### Указатели (pointers)
Объект является типизированной областью памяти. Функции при этом объектами не являются несмотря на то, что они также как и объекты могут занимать память. В C++ фундаментальной единицей хранения является байт, состоящий из последовательности бит, числокоторых определяется реализацией. Да, их в байте может быть не восемь, хотя это большая редкость. Каждый байт имеет уникальный адрес. Указатель хранит адрес байта с которого начинается типизированная память. Указатель однозначно связан с типом, который хранится по этому адресу. Указатели объявляются путем добавления символа '*' к идентификаатору.

```{r,engine='Rcpp',eval=F}
double *x; // неинициализированный указатель на double
double* y;// то же самое. и не важно, где стоит '*' но минимум один пробел нужен между идентификатором и типом;
A *pa; // укаазатель на объект
A* pa, *pb; // два указателя на объекты одного типа
```

Физически указатель представляет собой адрес памяти. Для 32-битных архитектур процессоров размер адреса как правило составляет 32 бита. Проверьте в своей среде разработки сами:
```{r,engine='Rcpp',eval=F}
cout << sizeof(A*)<<endl; // размер в байтах!
```
Инициализация указателей
```{r,engine='Rcpp',eval=F}
A a; // определение объекта с выделением памяти
A*pa = {&a}; // '&' - оператор взятия адреса объекта
A *pb=new A; // создание нового объекта в динамической памяти
A *pc{nullptr}; // инициализация указателем-литераом
```

Чтение значения по указателю
```{r,engine='Rcpp',eval=F}
double x{3.14}; // определение и инициализация 'x'
double *px{&x}; // '*' - указывает на то, что 'px' это указатель; '&' - оператор взятия адреса
cout << *px << endl; // вне определения оператор '*', разыменование указателя, означает объект, на который укаазатель ссылается. Результат:  3.14
```


Запись в память по указателю
```{r,engine='Rcpp',eval=F}
double x, *px{&x}; // объявление 'x' и там же объявление указателя на него
*px = 3.14; // "разыменование" указателя и запись по адресу на который он указывает
cout << x << endl; // 3.14
```

Арифметика указателей
Для работы с указателями возможно использование операторов сложения, вычитания и сравнения.
```{r,engine='Rcpp',eval=F}
if (pa != pb) // копирование объектов только если адреса разные
  *pa=pb;

while(*pa++ = *pb++); // копирование массива 'pb' в массив 'pa' до первого нулевого элемента
```

### Массивы
Массивы в C++ унаследованы от C и предсталяют собой последовательность элементов одного типа, расположенную в памяти непрерывно т.е. один за другим. Массив объявляется с помощью квадратных скобок:
```{r,engine='Rcpp',eval=F}
A aa[5]; // неинициализированный массив из 5 элементов от aa[0] до aa[4] типа 'A'
```

Размерность массива может быть вычислена по инициализирующему его выражению.
```{r,engine='Rcpp',eval=F}
int a[]={0,1,2};       // Инициализированный массив (a[3]={0,1,2}; )
char s[]="hello";      // Строка. Строки в C завершаются нулевым символом '\0'. В данном случае длина строки 6 символов, включая '\0'.
char* s="hello";       // указатель на строку "hello", включающую '\0'
A a;
A aa = {a,a,a}; // массив из 3 копий объекта 'a'
A bb = new A[3]; // массив из 3 новых объектов типа 'A', созданных в динамической памяти
```

Массив может быть многомерным:
```{r,engine='Rcpp',eval=F}
double xx[3][5]; // двумерный массив 3х5
double yy[2][3]={{1,2,3},{4,5,6}};  // Двумерный массив с элементами типа 'double'
double zz[][]={{1,2,3},{4,5,6}};  // То же самое, только не указаны размерности т.к. они понятны з инициализации
double vv[3][5][2]; // трехмерный массив 3х5х2. 
extern int n, m;
double ww[n][m]; // размерность может быть задана целочисленным литералом или выражением целого типа.
```

Массивы независимо от размерности занимают непрерывный блок памяти. При этом младшие размерности (указанные правее) изменяются быстрее.
Образец размещения в памяти трехмерного массива 'double yy[3][5][2]' приведен на рисунке: TODO

Доступ к элементам массива осуществляется по индексам. Нумерация индексов начинается с 0. Да, a[1] это второй элемент массива.

```{r,engine='Rcpp',eval=F}
for( int i=0; i<n; i++)
for( int j=0; j<m; j++)
    zz[i][j]=j+i*m;

for (auto &x: xx) // для записи переменная цикла должна иметь вид ссылки: auto &x. Т.к. тип элементов 'xx' известен, можно использовать переменную цикла типа double: double &x.
   xx = 0;
```

Чтение элементов массива:

```{r,engine='Rcpp',eval=F}
for( int i=0; i<n; i++)
for( int j=0; j<m; j++)
    cout << zz[i][j] << endl;

for (autox: xx)
   cout << xx << endl;
```

Массив в C++ реализован как указатель на первый элемент массива, соответственно возможны преобразования массива в указатель и операции с ним
```{r,engine='Rcpp',eval=F}
#include <typeinfo>
A aa[5], *pa = aa;
if(typeid(pa) != typeid(aa))
{
  cout << typeid(pa).name() << endl;
  cout << typeid(aa).name() << endl;
}
*(pa+1); // второй элемент массива -- то же самое что и pa[1], aa[1] или *(aa+1)
```
Двумерный массив - это массив массивов или указатель на казатель.
```{r,engine='Rcpp',eval=F}
A aaa[3][4],**ppa=aaa, *pa=aaa[0]; // здесь 'pa' - указатель на первый из блоков по 4(второе измерение)???
```

Есть также такое понятие, как указатель на функцию:
```{r,engine='Rcpp',eval=F}
int (∗f)(float)=nullptr; // Неинициализированный указатель на функцию, 
                         // возвращающую int с одним параметром float
x[0] = f(3.14f);         // Вызов функции через указатель
```

Упражнение: написать процедуру умножения матриц фиксированной размерности


### Ссылки (reference)
Ссылки являются синонимами для имени объекта. Ссылки объявляются путем добавления символа '&' к идентификатору. Ссылки обязательно должны быть инициализированы. Обращение к ссылкам производится так же как и к объектам.
```{r,engine='Rcpp',eval=F}
double &rx = x; // в этом контексте символ '&' означает ссылку.
rx=3.14;
cout<<x<<endl; // 3.14
```
В отличие от указателей ссылки не могут быть неинициализированными или иметь нулевое значение, невозможно изменить значение ссылочного объекта - работа с ним происходит как с синонимом объекта, на который он ссылается. 
Между ссылкой и указателем действуют операторы преобразования
```{r,engine='Rcpp',eval=F}
A a;
A *pa{&a};
A &ra{*pa}; // получение ссылки по указателю на объект. Результат - ссылка нобъект, на который указывает указатель
pa=&ra; // взятие адреса объекта по указателю на этот объект. Результат - указатель на объект 'a'.
```
Ссылки могут ссылаться на константные объекты
```{r,engine='Rcpp',eval=F}
const A a;      // константа
const A& cr=a;  // cr является ссылкой на константу
```

В C++11 появились ссылки на временные объекты, не имеющие собственного имени (rvalue-references), которые можно использовать для переменщения объектов. При обычном копировании объект-источник продолжает существовать и производися накладная операция копирования старого объекта в новый объект. При перемещении же старый объект переносится в новый без дублирования данных. Ссылки на временные объекты объявляются путем добавления двух символов '&&' к идентификатору.


TODO:
```{r,engine='Rcpp',eval=F}
A &&r1 = f(); // ссылка на возвращаемое функцией значение
A &&r2 = {0,0}; // ссылка на литерал
A &&r3 = move(a); // функция  move() превращает объект в rvalue
```

NB: терминология rvalue/lvalue появилась до C++ и изначально означала выражения, которые могут быть слева от оператора присваивания и выражения, которые могут стояь  справа от знака присваивания.


### Константы (const values)
Можно запретить изменение объекта программой сделав его тип константным. При этом объект получит новый тип, отличающийся от неконстантного. Запрет изменения (константность) задается ключевым словом *const*.
```{r,engine='Rcpp',eval=F}
const int c=3;        // константа всегда инициализируется
const A a;            // константный (неизменяемый) объект
A const b;            // то же самое
```

Константность может сочетаться с указателями и ссылками.
```{r,engine='Rcpp',eval=F}
const int* p=a;        // Значения, на которые указывает p константны
int* const p=a;        // Указатель p является константой
const int* const p=a;  // Все константы, и значение и указатель

const A *pa = {&a};   // указатель на константный объект
const A &ra = {a};    // ссылка на константный объект
*pa = b;              // ошибка: объект 'a' изменять нельзя, он константный
pa=nullptr;           // а сам указатель не константный
a = b;                // ошибка: объект 'a' изменять нельзя
```

Будет легче понять смысл типа, если читать справа на лево. Например, " const int\*" - указатель на целую константу. " int\* const " - константный указатель на целое.


Константный объект должен быть инициализирован в момент определения. Инициализатором может выступать как литерал, известный в момент компиляции, так и выражение или просто объект, получаемые во время исполнения программы.

Для преобразования указателя или ссылки на объект константного типа в укзатель или ссылку на неконстантный объект используется оператор const_cast<неконстантный тип>(выражение), возвращающий значение указанного неконстантного типа:
```{r,engine='Rcpp',eval=F}
const int i = 0;
const_cast<int>(i)=1; // изменение значения константы
```
(оператор может аналогично const изменять спецификатор volatile)

### Константное выраженние (constexpr)
Во время исполнения компилятор может производить вычисления их результат использовать в окончательном коде программы. Исходными данными для вычисления могут быть перечисления, арифметические и пользовательские литералы. При этом можно использовать функции, определеные как constexpr и операторы, не меняющие операнды (не '++', '--', '=' и комбинированнные). Пример:

```{r,engine='Rcpp',eval=F}
constexpr double pi=3.14;
// constexpr площадь круга 
constexpr double area(double d)
{
  return pi*d*d/4;
}
int main()
{
  double s = area(4); // вычисляется во время компиляции
}
```


В вычислениях могут участвовать простые пользовательские классы. Для этого они должны иметь конструктор типа constexpr. Особое изящество эта конструкция приобретает при использовании пользовательских литералов:
TODO:
```{r,engine='Rcpp',eval=F}
class Speed
{
double value; // скорость в метрах в секунду
public:
constexpr Speed(Speed speed):value{speed.getvalue()}
{  
}
double getvalue(){return value;}
};
Speed operator"" _ms()
Speed operator"" _kmh()
Speed operator"" _mph()

Speed s={50_kmh};
cout << s.getvalue() << endl;
```


### Составные и прочие типы данных
 
Язык предоставляет программисту средства для создания новых типов данных, расширяющих фундаментальные типы. Ключевым способом создания новых типов являются классы. Они будут предметом подробного описания в разделе объектно-ориентированное программирование. Здесь будут кратко перечислены прочие типы, доступные в языке.

#### Перечисления (enum)
Перечисления - это тип данных, объекты которого могут принимать ограниченное число значений.
```{r,engine='Rcpp',eval=F}
enum state {on,off};     // тип перечисления со значениями ON=0 и OFF=1
enum state st;          // переменная типа state может принимать только значения перечисления 'state'
```
Перечисление создает в области видимости новые имена значений перечисления. В данном случае это 'on' и 'off'.
```{r,engine='Rcpp',eval=F}
enum state {on=0,off=1}; // Явное определение значений
state st;                // Определение объекта 'st'. Ключевое слово 'enum' не обязательно.
enum {on,off} st;        // Анонимный тип перечисления (объект назван, а тип - нет)
```
Перечисления были реализованы как целочисленные значения, поэтому если перечисление не типизировано, возможно свободное преобразование значения перечисления в целое.

```{r,engine='Rcpp',eval=F}
state st;
st = off;
int x = st;
int y = off;  
```

Перечисления могут быть типизированными с указанием базового типа, лежащего в их основе (underlying type). Типизация добавляется ключевым словом *class*.
```{r,engine='Rcpp',eval=F}
enum class state : bool {on=true,off=false}; // типизированное перечисление. базовый тип - bool
state st = state::off;   // Пример использования
state st = off;          // Ошибка - значение перечисление находится в облати видимости типа 'state'
state st = false;        // Ошибка - литерал false не принадлежит типу state 
bool b = st;             // Ошибка - тип 'st' не совместим с 'bool'
```

#### Структуры (struct)
Объекты уже известных нам типов могут быть объединены в группы, называемые структурами
```{r,engine='Rcpp',eval=F}
struct T{                // структура: составной тип из набора данных и методов
  double x;              // поля структуры, являющиеся данными
  double y;
  double mod(){          // метод - функция, вложенная в структуру
    return sqrt(x*x+y*y);
  }
};
```
Объявление объектов-структур:
```{r,engine='Rcpp',eval=F}
T s;              // без инициализации
T q{1.0, 2.0};    // x=1.0, y=2.0
T *p = &q;
```


Обращение к методам и полям класса происходит с помощью операторов селекторов. Для объектов и ссылок:
```{r,engine='Rcpp',eval=F}
s.x = 1.0; // запись значений в поля
s.y = 1.0;

cout << s.x; // чтение значений полей для вывода

p->y = 1;
cout << s.mod();  // 1.41421
cout << p->mod(); // 2.23607
```
Для указателей
```{r,engine='Rcpp',eval=F}
p->x= -1; // используя селектор указателя
cout << p->x;
pa->mod();

cout << (*p).x;// либо разыменовывая указатель
(*p).mod();
```

Структуры могут содержать другие структуры.
```{r,engine='Rcpp',eval=F}
// Структура, задающа точку на плоскости
struct Point 
{
    double x;
    double y;
};
// Структура, задающая линию между двумя точками на плоскости 
struct Line 
{
    Point start;
    Point end;
} line1;
Line *pline = &line; // указатель на объект типа Line
```
Можно даже определять одни структуры внутри других - вложенные структуры (nested).
```{r,engine='Rcpp',eval=F}
// Структура, задающая линию между двумя точками на плоскости 
struct Line 
{
    // Структура, задающа точку на плоскости
    struct Point 
    {
       double x;
       double y;
    };
    Point start;
    Point end;
} line;
Line *pline = &line; // указатель на один из объектов
```
Структуры, как и перечисления могут быть анонимными. Т.е. тип структуры не получит имени и его нельзя будет использовать в другом месте программы. Обратите внимание на отсутствие названия типов из предыдущего примера 'Line' и 'Point'.
```{r,engine='Rcpp',eval=F}
// Структура, задающая линию между двумя точками на плоскости 
struct 
{
    // Структура, задающа точку на плоскости
    struct 
    {
       double x;
       double y;
    } start, end;
} line;
Line *pl1 = &line; // указатель на один из объектов
```

Обращения к полям осуществляется с помощью селекторов. Только в слеучае вложенных структур они также становятся вложенными. Например:
```{r,engine='Rcpp',eval=F}
line.start.x = 0;
pline->end.y = 0;
```

#### Объединения (union)
Объединения - группы данных, в которых для их хранения используется одно и то же пространство памяти.
```{r,engine='Rcpp',eval=F}
union Bytes {
   int i;
   float f;
   char c[4];
} bytes;
```
В этом примере bytes.i, bytes.f, bytes.c[4] расположены в одном месте в памяти. Размер членов объединения не обязательно должен совпадать. Объединения удобно использовать для переинтерпретации содержимого памяти, например если требуется побайтная передача данных с последующей интерпретацией полученного потока, или для экономии памяти.

```{r,engine='Rcpp',eval=F}
#include <iomanip> 
using namespace std;
union Bytes {
    int i;
    float f;
};

int main () 
{
    Bytes u;
    u.f = 3.14f;
    
    cout << hex;
    cout << setiosflags (ios::showbase);
    cout << u.i << endl;
    return 0;
}
```

#### Битовые поля
Битовые поля позволяют оперировать структурами, состоящими из отдельных битов.
```{r,engine='Rcpp',eval=F}
struct Date {
   unsigned int year   : 23;// 23 бита достаточно для хранения значений 0-8388607
   unsigned int month  : 4; // 5 бита достаточно для хранения значений 0-15
   unsigned int day    : 5; // 5 битов достаточно для хранения значений 0-31
};
```
В этой структуре год занимает 23 бита, месяц 4 бита и день 5 битов. В памяти эти биты хранятся последовательно, и вся структура из примера займет 32 бита. Для выравнивания битовое поле может не иметь имени. Неименованное поле 0-й длины приводит к выравниванию до следующей границы, кратной размерности базового типа члена битового поля (в данном случае 'unsigned int'). В качестве базового типа можно указать любой из арифметических фундаментальных типов. Обращение к членам битового поля подчиняется тем же правилам, что и доступ к членам обычных структур.
```{r,engine='Rcpp',eval=F}
cout << dec << setfill ('0'); // в предыдущем примере вывод переключался на 16-ричный формат, возвращаем к десятичному

Date date={2014,9,1}; // инициализация при объявлении
cout << setw(2) << date.day << "." << setw(2) << date.month << "." << date.year << endl;
// изменение полей объекта
date.year = 2013;
date.month = 8;
date.day = 31;
// изменение полей объекта по указателю на объект
Date *pdate=&date;
pdate->year = 2015;
pdate->month = 1;
pdate->day = 1;
cout << setw(2) << date.day << "." << setw(2) << date.month << "." << date.year << endl;
```


Для типов, уже сществующих в программе, можно вводить новые названия, синонимы типов. Для этого есть два механизма: typedef и using. В примерах ниже создаются названия типов Str и DWORD.
```{r,engine='Rcpp',eval=F}
typedef char* Str;       // тип 'Str' является синонимом 'char*'
using Str=char*;         // то же самое, только более понятным образом

typedef unsigned long int DWORD;
using DWORD=unsigned long int;         
```
Далее можно объявлять объекты нового типа:
```{r,engine='Rcpp',eval=F}
Str s="hello";
```

### Типы данных стандартной библиотеки 
Стандартная библиотека C++ (C++ Standard Library) предоставляет набор готовых библиотек, реализующих разнообразные базовые алгоритмы, типы и функции. Основные категории библиотек:
* языковая поддержка
* диагностика
* общие утилиты
* строки
* локализация
* контейнеры
* итераторы
* алгоритмы
* числовая библиотека
* ввод/вывод
* регулярные выражения
* атомарные операции
* поддержка поткового исполнения
Все имена стандартной библиотеки принадлежат пространству имен std. Для доступа к ним необходимо использовать разрешение области видимости 'std::...' или директиву 'using namespace std;' Описать все нет ни места ни смысла. Ниже очень кратко будут упомянуты возможности основных библиотек, которые могут понадобиться при разработке программ моделирования.

#### Строки (string)
В библиотеке реализован тип для рабты со строками. Библиотека подключается директивой '#include <string>' в единице трансляции, в которой необходимо использование типов и объектов, определенных в ней.


```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <string>
using namespace std;
 
int main ()
{
  string name={"Jekky"}; // тип 'string' определен в <string>
  string family={"Chan"};
  cout << name + " " + family << endl; // конкатенация (сложение) строк
 
  string str{"my constant string literal"};
  str.replace(str.begin()+3,str.end(),"replaced string"); // метод 'replace' реализован в стандартной библиотеке
  cout << str<< endl;
   
  return 0;
}
```

#### Массив числовых данных (valarray)
Это класс для работы с массивом числовых данных, предоставляющий кроме функций массива как контейнера, методы для работы с его числами: поиск минимального из чисел массива, максимального числа, суммы и т.д. Размерность задается при определении массива.
```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <valarray>
#include <random>
using namespace std;
int main ()
{
  // Ввод размерности массива
  int n=0;
  cout << "n=";
  cin >> n;
  // Массив из n чисел типа 'int'. Можно использовать другие арифметические типы, для котрых определены операции сложения, вычитания, сравнения.
  valarray<int> intvals (n);
 
  // Генератор случайных чисел
  default_random_engine engine;
  // Равномерное распределение от 0 до 4 включительно
  uniform_int_distribution<int> distribution(0, 4);
 
  for (auto &i:intvals)
      i = distribution(engine);
 
  for (auto i:intvals)
      cout << i << endl;
  cout << "sum=" << intvals.sum() << endl;
  cout << "min=" << intvals.min() << endl;
  cout << "max=" << intvals.max() << endl;
  return 0;
} 
```

#### Массив элементов одного типа (array)
Массив фиксированного размера для работы с любым типом элементов, не только числовыми.
```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <array>
using namespace std;
int main ()
{
  array<int,3> intvals;
  intvals[0]=10;
  intvals[1]=20;
  intvals[2]=30;
  for (auto i:intvals)    
    cout << i << endl;
  return 0;
} 
```


#### Вектор (vector)
Динамический массив, в который можно добавлять и убавлять элементы.Элементы добавляются в конец вектора методом 'push\_back()' и удаляются 'pop\_back()'. При добалении элемента размер вектора увеличивается на один элемент.
```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <vector>
using namespace std;
int main ()
{
  vector<int> intvals(3); // вектор из 3-х элементов (равны '0')
  intvals.push_back(10);  // добавление 4-го элемента
  intvals.push_back(20);  // добавление 5-го элемента
  intvals.push_back(30);  // добавление 6-го элемента
  for (auto i:intvals)    
    cout << i << endl;
  return 0;
}
```

#### Двумерный массив заданной размерности
Готовых многомерных массивов в стандартной библиотеке нет, но возможно использовать существующие одномерные массивы для конструирования многомерного.
```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <array>
using namespace std;
 
int main ()
{
    // Матрица из MxN чисел (M строк, N столбцов)
    const int M{4},N{3}; // размерности должны быть const или constexpr
    array< array<double,N>, M> matrix; // массив, элементами которого являются тоже массивы.
    // Можно создать синоним типа следующим образом
    // using Matrix=array< array<double,N>, M>;
    // Объявление матричного объекта будет выглядеть понятнее:
    // Matrix matrix
 
    // Инициализация
    int count=0;
    for (auto &row:matrix)
        for (auto &cell:row)
            cell = count++;
 
    // Вывод (можно сделать по аналогии с инициализацией с помощью цикла range-for)
    for (int i = 0; i<M;i++)
    {
        for(int j = 0; j<N;j++)
        {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
 
    return 0;
}
```

#### Двумерный массив переменной размерности
Для создания массива переменной размерности следует использовать динамеически расширяемый 'vector'.
```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <vector>
using namespace std;
 
int main ()
{
    // Ввод размерности массива
    int n{0},m{0};
    cout << "Enter dimensions" << endl;
    cout << "n="; cin >> n;
    cout << "m="; cin >> m;
 
    // Синонимы типов: ряда, и 2-мерного массива
    typedef vector<double> row_in_array2d;
    typedef vector <row_in_array2d> array2d;
 
    // Матрица из MxN чисел (M строк, N столбцов)
    row_in_array2d row_value(n);
    array2d matrix(m,row_value);
 
    // Инициализация
    int count=0;
    for (auto &row:matrix)
        for (auto &cell:row)
            cell = count++;
 
    // Вывод
    for (int i = 0; i<m;i++)
    {
        for(int j = 0; j<n;j++)
        {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
 
    return 0;
}
```

TODO:
### Ввод-вывод, чтение/запись файлов
### Генерация случайных чисел


### Область видимости (scope)
Объекты и функции должны быть объявлены до их первого использования в программе. После объявления объект может быть использован в пределах своей *видимости*. Объект может иметь глобальную или локальную область видимости. Глобальные объекты, которые могут быть использованы в любом месте программы, объявляются вне блоков кода и функций в то время как локальные объекты объявляются внутри. Область видимости локальных объектов ограничена пространством внутри фигурных скобок ({}), в которых они объявлены. Таким пространством могут служить блок кода, функция, класс, пространство имен.

```{r,engine='Rcpp',eval=F}
// глобальные объекты (переменные)
A aobj; // объект доступен в любой точке кода после своего объявления
double x;
...
int main()
{
   //локальные объекты
   double y;
   if(x!=0 || y!=0) // 'x' инициализирован 0, а 'y' содержит случайное значение
   {
      int i; //локальная переменная. может использоватьсятолько внутри блока if
      aobj.print();//использование глобальной переменной
  
   }
   ...
}
```
Глобальные переменные фундаментальных типов инициализируются значением 0, для объектов классов вызывается указанный при определении конструктор или конструктор по умолчанию, инициализирующие объект заданным образом.

### Классы памяти (storage duration)
Объекты размещаются в памяти в соответствии со своими классами памяти: 
*automatic* - объект существует внутри блока, и удаляется при выходе из него. Размещение происходит в стеке программмы.
*static* - объект размещается при запуске программы и удаляется из памяти при её завершении. Размещение происходит в BSS сегменте памяти программы.
*thread* - объект размещается при запуске потока и удаляется из памяти при его завершении. 
*dynamic* - объект размещается и удаляется при вызове функций динамической памяти. Размещение происходит в свободной динамической памяти программы (heap)
```{r,engine='Rcpp',eval=F}
A a1; //  static - глобальный объект, создаваемый при запуске проограммы в момент "до его первого использования"
static A a2; // static - то же самое, только область видимости ограничена данным модулем трансляции
int main()
{
    {
        A a2;               //automatic - объект создается в момент объявления и существует до конца исполнения блока или функции
    } //здесь объект 'a' будет разрушен идалее он недоступен
    {
        static A a3;        // static - объект создается при запуске программы, инициализируется конструктором по умолчанию (переменные фундаментальных типов инициализируются 0), существует постоянно до завершения программы, доступ данном случае только локальный т.к. объект объявлен в блоке
        extern A a4;        // объявление, не приводящее к размещению в памяти.
        register A a5;      // automatic - объект существует в области видимости, по возможности в регистровой памяти процессора
        thread_local A a6;  // thread - объект существует во время исполнения потока. здесь поток один - основной поток, в котором выполняется main()
    }
}
```

Объекты могут быть созданы в любой момент в динамической памяти глобальными функциями размещения
```{r,engine='Rcpp',eval=F}
void* operator new(std::size_t);
void* operator new[](std::size_t);
```
и удалены соответствующими им функциями удаления:
```{r,engine='Rcpp',eval=F}
void operator delete(void*);
void operator delete[](void*);
```

Пример
```{r,engine='Rcpp',eval=F}
int main()
{
    A *a = new A; // создание объекта в памяти
    // ... использование объекта
    delete a; // удаление объекта из памяти. Дальнейшее использование невозможно несмотря на то, что укаазатель 'a' продолжает хранить адрес.
}
```

В случае automatic, static и thread компилятор самостоятельно создаст и удалит такие объекты по перечисленным выше правилам. В случае динамического размещения забота о своевременном создании и удалении объектов лежит на разработчике программы, которому придется решить две возникающие проблемы: неудаление созданных и больше не используемых объектов, приводящее к непроизводительному задействованию ресурсов, например, утечкее памяти, и несвоевременное удаление объектов, которые еще используются в программе. Для избежания таких ситуаций существуют умные указатели (smart pointers). Такие указатели реализованы как классы, точнее шаблоны классов, и содержат помимо собственно указателя счетчик своих копий. Объект, на который сссылается указатель удаляется из памяти, когда счетчик копий становится равным нулю.

TODO: (http://230100.msiu.ru/files/48380-std_overview.html)
Примеры владеющих указателей
weak_ptr
shered_ptr
unique_ptr








## Управление выполнением
В языках, родственных процедурным, исполнение программы происходит последовательно. Это не универсальное правило, но как правило это так и направление исполнения совпадает с последовательностью чтения строк программмы сверху вниз. Отчасти это соответствует архитектуре процессора, в которой (у каждого ядра) есть счетчик инструкций (progrramm counter, PC), автоматически увеличиваемый процессором при исполнении каждой процессорной инструкции. Исполнение кода происходит условно следующим образом:
```{r,engine='Rcpp',eval=F}
uint32_t pc= main; // начало исполнения с функции main, счетчик указывает на начало
while(true) // бесконечный цикл
  execute(*pc++); // исполнение текущей инструкции и увеличение счетчика ('*pc' - разыменование указателя, т.е.чтение инструкции по адресу, который он содержит; 'pc++' увеличение адреса на единницу - указатель на следующую инструкцию) инструкций.
```

Примеры инструкций процессора с системой команд x86:
```{r,engine='Rcpp',eval=F}
; Сложение
ADD r0, r1, r2  ; r0 = r1 + r2
; Вычитание
SUB r0, r1, r2  ; r0 = r1 — r2
; Умножение
MUL r0, r1, r2  ; r0 = r1 * r2
; Копирование
MOV r0, r1      ; r0 = r1
; Логическое ИЛИ
ORR r0, r1, r2  ; r0 = r1 | r2
; Загрузка
LDR r4, [r5]    ; r4 = *r5
; Сохранение
STR r4, [r5]    ; *r5 = r4
; Переход исполнения на соответствующий адрес
B  label
```
Компилятор из исхдного текста выстраивает эти и другие инструкции процессора в последовательность в памяти. Процессор читает и выполняет эту последовательность в потоке исполнения (thread), исполняемый одним ядром.

Последовательностью исполнения кода можно управлять с помощью управляющих операторов (statements), обеспечивающих ветвление и управление циклами. Также исполнение можно разбивать на блоки кода, вызываемые по имени - функции. Определение функции выглядит следующим образом:
```{r,engine='Rcpp',eval=F}
<тип возвращаемого значения. если значение не возвращается, то тип 'void'> <имя функции в соответствии с правилами именования идентификаторов>(разделенный запятыми список формальных параметров с их типами. параметров может не  быть)
{
... // операторы тела функции
}
```
Вызов функции:
```{r,engine='Rcpp',eval=F}
<имя функции>(список фактических параметров);
```

Примеры:
```{r,engine='Rcpp',eval=F}
int f(int x, int);        // f функция принимающая 2 int, возвращающая int
void f();                 // f функция без параметров
void f(int a=0);          // Значение параметра по умолчанию f()
                         // эквивалентно f(0)
inline void f();               // Развернуть код функции в месте вызова
T f() { statements; }     // определение функции, возвращающей T
T operator+(T x, T y);    // бинарный оператор сложения x+y
T operator-(T x);         // унарный оператор. '-x' вызывает 'operator-(x)'
extern "C" {void f();}    // объявление f(), которая была скомпилирована на C
```

Функция должна быть объявлена или определена перед использованием.
Функции с одинаковым именем, но различными параметрами являются разными функциями и выбираются в зависимости от параметров (перегружаются).
Операторы за исключением "::" "." ".*" "?:" могут быть перегружены. Приоритетность при этом не изменяется. Новые операторы созданы быть не могут.


Объявление функции должно предшествовать ее использованнию (вызову). Напоминаем, что определение также является объявлением.

Пример:
```{r,engine='Rcpp',eval=F}
// Определение функции sinus
double sinus(double x)
{
   ...
   return retval; // возвращаемое значение должно было быть вычислено в теле функции
}
// Определение функции pow(), возвращающей степень первого параметра/ Второй параметр - значение степени.
double pow(double x, int n)
{
...
   return retval;
}
// определение функции извлечения квадратного корня
double squareroot(double x)
{
...
return retval;
}
// определение функции print
void print()
{
  cout << "hello world"; 
}
// Вызов функции
double x=sinus(0.1);
double y=pow(x,2);
print();
```

При передаче параметров можно использовать как их значение так и ссылки или указатели. При передаче по значению фактический параметр, существующий в вызывающем коде, копируется в формальный параметр. Поэтому все иизменения параметров внутри функции не отражаются в вызывающей программе. При передаче по значению в прототипе функции указаны типы параметров.
```{r,engine='Rcpp',eval=F}
void f(A a) // параметр можно назвать любым именем на свой вкус. Как его назовете, так и придется к нему обращаться в теле функции. Здесь 'A a' является определением локального для функции объекта
{
  a.x = -1.0;
}

A a{0,0};
f(a);
cout << a.x; // 0.0
```

При передаче по ссылке значения не копируются, в функцию передаются ссылки на параметры. Следствием этого является возможность внутри функции параметры изменить и увидеть эти изменения в том месте, откуда функция была вызвана.
```{r,engine='Rcpp',eval=F}
void f(A &a) // передача 'a' по ссылке
{
  a.x = -1.0;
}
A a{0,0};
f(a);
cout << a.x; // -1.0
```


При передаче указателя в функцию происходит копирование значения этого указателя но не объекта, на который он указыает. Поэтому объект из функции можно изменить, значение указателя - нет.
```{r,engine='Rcpp',eval=F}
void f(A *pa) // передача указателя 'pa'
{
  pa->x = -1.0;
  pa=nullptr; // не имеет эффекта за пределами функции 'f'
}
A a{0,0};
f(&a); // передача адреса 'a' в функцию. оператор '&' - взятие адреса объекта
cout << a.x; // -1.0
```


TODO: Указатели на функции
```{r,engine='Rcpp',eval=F}
#include <iostream>
using namespace std;
 
int addition (int a, int b)
{ return (a+b); }
 
int subtraction (int a, int b)
{ return (a-b); }
 
int operation (int x, int y, int (*functocall)(int,int))
{
 int g;
 g = (*functocall)(x,y);
 return (g);
}
 
int main ()
{
 int m,n;
 int (*minus)(int,int) = subtraction;
 
 m = operation (7, 5, addition);
 n = operation (20, m, minus);
 cout <<n;
 return 0;
}
```


Функции внутри функций объявлять и определять нельзя. Функции могут принадлежать классу (методы класса), пространству имен в т.ч. глобальному ::f(), единице трансляции (static).

```{r,engine='Rcpp',eval=F}
#include <iostream>

class A
{
    double x,y;
    public:
    double mod(); // объявление метода класса A::mod()
};
// определение метода класса A::mod()
double A::mod()
{
    return squareroot(x*x+y*y);
} 

// определение глобальной функции
double mod(A &a)
{
    return squareroot(a.x*a.x+a.y*a.y)
} 

// определение статической (локальной для данной единицы трансляции) функции. Вызвать эту функцию из другого файла не получится т.к. она объявлена 'static'.
static double smod(A &a)
{
    return squareroot(a.x*a.x+a.y*a.y)
} 

namespace example_space
{
    // определение функции внутри пространства имен
    double mod(A &a)
    {
        return squareroot(a.x*a.x+a.y*a.y)
    } 
}

int main()
{
    A a{0,0};
    cout << a.mod() << endl; // использование (вызов) метода класса
    cout << mod(a) << endl; // использование глобальной функции
    cout << smod(a) << endl; // использование статической функции
    cout << example_space::mod(a) << endl; // использование функции из пространства имен
} 
```

Зато язык предоставляет возможность создания объектов-функций -- функторов, лямбда-функций и замыканий.

#### Функтор
В классе может быть определен оператор '()'.
```{r,engine='Rcpp',eval=F}
class A
{
  double x,y;
public:
 double mod();
  double operator()(int pow)
  {
   double retval = mod();
    for(int i=0;i<pow;i++)
      retwal *= retwal; // умножение величины на само себя
  }
  return retval;
};

// пример использования функтора
int main()
{
 A a{1,1};
  cout << a(2) << endl; // вызов функтора
}
```

Лямбда-функция (lambda, lambda function, lambda expression) - это еще один механизм создания функторов. Рассмотрим пример:
```{r,engine='Rcpp',eval=F}
auto f = [](double x, int i){ return pow(x,i);};
```

TODO
Здесь 
* 'auto f' -- объявление объекта-лямбда-функции. Тип, характеризуемый списком параметров, типом возвращаемого значения и телом лямбда-функции выводится автоматически. 
* [] -- список захвата локальных переменных. (переменных из области видимости)
если список пуст '[]', то переменнные не захватываются и в лямбде недоступны
если список выглядит так: '[&]', то захватываются все локальные переменные по ссылке
если список выглядит так: '[=]', то захватываются все локальные переменные по значению
Можно указать способ захвата для отдельных локальных объектов:
[&x,=y] -- 'x' захвачен по ссылке, 'y' по значению. Остальные объекты не захвачены.



### Оператор условного исполнения
Оператор предназначен для исполнения того или иного блока кода в зависимости от условия
```{r,engine='Rcpp',eval=F}
if (x) a;                 // Если выражение 'x' равно true (или отлично от 0), выполнить оператор 'a'. 
else if (y) b;            // иначе если выражение 'y' равно true, выполнить оператор 'b'
else c;                   // если ни одно из условий 'x' и 'y' не выполнено
... // продолжение исполнения кода
```
 
Оператор 'a' и 'b' могут быть составными, т.е. состоять из одного или нескольких операторов, заключенных в фигурные скобки
```{r,engine='Rcpp',eval=F}
{                         // открывающая скобка блока, составного оператора
 A a;                  // можно определять объекты,'a' видима внутри блока
 a.sin();                      // определения должны предшествоватьих использованию 
}
```

Размещение операторов в строках исходного текста не определено строго и зависит от принятого стиля оформления программы. Примеры разных стилей:
```{r,engine='Rcpp',eval=F}
if( x>0 ){
  y = 0;
}
else {
  y = x;
}

if( x>0 )
{
  y = 0;
} 
else 
{
  y = x;
}

if( x>0 )
  y = 0;
else
  y = x;
```

Программист вправе руководствоваться собственным вкусом при выборе форматирования. Вариант стиля кода можно посмотреть здесь:
[http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml]
Согласно этому стилю рекомендуется писать так:
```{r,engine='Rcpp',eval=F}
if (condition) {  // no spaces inside parentheses
  ...  // 2 space indent.
} else if (...) {  // The else goes on the same line as the closing brace.
  ...
} else {
  ...
}
```

### Циклы  
#### Цикл while
Это цикл, который выполняется пока условие (выражение), указанное в круглых скобках оператора while, истинно (если быть точным и откровенным, то ради поддержки конструкций языка 'C', не имевшего типа bool, пока условие не равно нулю).
```{r,engine='Rcpp',eval=F}
while (x) a;              // Повторить 0 и более раз пока x равен true
```
Цикл используется в случаях, когда число повторений заранее неизвестно и может быть нулевым. Пример чтения файла.
```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <fstream>

using namespace std;

ifstream file("dat/example-001-in.txt"); // файл для чтения
while( file.good() ) // проверка достижения конца файла
{
    wchar_t wc = file.get();
    wcout << wc; // вывод содержимого на консоль ('wcout' - аналог 'cout' для символов типа 'wchar_t')
}
```

#### Цикл do-while
Цикл также выполняется до тех пор, пока условие истинно. Его отличие от 'while' в том, что этот цикл будет выполнен минимум один раз.
```{r,engine='Rcpp',eval=F}
do a; while (x);          // Повторить 1 и более раз пока x равен true
                         // Эквивалентно:: a; while(x) a;
```
Пример подскажет жизнь.

#### Цикл for
Самый распространенный способ сделать цикл - использовать оператор 'for'. Оператор внутри себя использует три выражения.
```{r,engine='Rcpp',eval=F}
for (x; y; z) a;          // Эквивалентно: x; while(y) {a; z;}
```
Очень часто, хотя и не всегда, оператор используется для циклов со счетчиком или циклов с итераторами (объектами доступа к элементам контейнера)
```{r,engine='Rcpp',eval=F}
// пример со счетчиком
for(int i = 5; i > 0; i--)
    cout << i << " "; // здесь может быть составной оператор, обраленный фигурными скобками
cout << endl; // перевод строки выполняется уже после завершения цикла

// пример с итератором
vector<int> v{1,2,3,4,5}; // в данном случае контейнером является 'vector'
for(auto it=v.begin();it != v.end(); ++it)
    cout << *it << " ";
cout << endl;

```

#### Цикл по диапазону (range based for)
Удобной заменой цикла с итератором является цикл по диапазону, появившийся в C++11.
```{r,engine='Rcpp',eval=F}
for (x: y) a; // x - переменная цикла, означающая элемент контейнера; y - контейнер
```

```{r,engine='Rcpp',eval=F}
//  range-for со стандартным контейнером vector
for(auto v: vv) 
    cout << v;
cout << endl;

// range-for с обычным массивом
int cc[] = {1,2,3,4,5};
for(auto &c: cc) c = 0; // если использовать ссыки то можно мерять значение переменной цикла
for(int &c: cc) c = 1; // то же самое, только явно указан тип элемента

// range-for для заданного списка значений
for (auto c: {1,2,3,4,5}) cout << c;
cout << endl;
```



Оператор 'continue' передает управление в конец цикла. Оператор 'break' завершает исполнение цикла.
```{r,engine='Rcpp',eval=F}
while (true)
{
char c = file.get();
if( !file.good() ) // ошибка чтения из файла
  break;
if (c >= '0' && c <= '9') // пропустить обработку цифр
 continue;

cout << c;
}
```
```{r,engine='Rcpp',eval=F}
while(true) continue; // просто бесконечный цикл.То же что и while(1); или for(;;); только более наглядно.
```


#### Оператор switch
Используется для выбора среди большого числа вариантов, например при обработк параметров командной строки, в которой  может использоваться множество разнообразных ключей.
```{r,engine='Rcpp',eval=F}
switch (x) {              // x должен быть целочисленным (т.е. char, enum, bool тоже подойдут)
 case X1: a; break;            // если x == X1 (константа), выполнить a
 case X2: b; break;            // иначе если x == X2, выполнить b
 default: c;             // если ни одно условие не выполнено (опционально)
}
```
Оператор break здесь необязателен. Он используется для перехода в конец оператора switch:

```{r,engine='Rcpp',eval=F}
switch(x)
{
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
 ...// обработка цифровых символов
break;
default:
...// обработка всех прочих символов
}
```


### goto
Пользоваться этим оператором категорически не рекомендуется. Тем не менее он есть.
```{r,engine='Rcpp',eval=F}
some_label:
...
goto some label;
```

### Возврат из функции
Оператор возвращает управление из функции в вызывающий контекст, то есть туда, откуда функция была вызвана и, если функция возвращает значение, передает его.
Возможно использование нескольких равноценных форм оператора - со скобками и без. 
```{r,engine='Rcpp',eval=F}
return x; // x - любое выражение с типом совпадающим с типом возвращаемого значения функции
return (x);   
```


### Обработка исключений
```{r,engine='Rcpp',eval=F}
try { a; }
catch (T t) { b; }        // Если a выкидывает исключение типа T
catch (...) { c; }        // во всех остальных случаях
```

```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <exception>
#include <stdexcept>
using namespace std;
  
int main()
{
    try {
        cout << "Starting" << endl;
        throw runtime_error("test exception");
        cout << "Ending" << endl;
    } catch (const exception& e) {
        cout << "Exception caught: " << e.what() << endl;
    }
}
```

## Объектно-ориентированное программирование
### Объявление и определение классов
Класс (class) - составной тип данных, содержащий поля и методы. Поля и методы могут использоваться извне класса, например, при вызове методов в том месте, где класс был создан. Поля и методы класса также могут использоваться внутри самого класса в его методах. Для ограничения доступа к внутреннему устройству класса извне существуют модификаторы доступа:
* 'public' - поля и методы доступны извне класса
* 'private' - поля и методы закрыты извне и доступны только внутри класса
* 'protected' - аналогично предыдущему, поля и методы закрыты для доступа извне (есть отличия при наследовании классов, которые будут описаны в соответствующем разделе) 

Внутри класса все его содержимое, и поля и методы, всегда доступны. Т.е. метод может обращаться к любым данным и другим методам своего класса независимо от их модификатора доступа.   Класс не отличается от структуры (struct) ничем, кроме того что по умолчанию в структуре все члены открыты (public), а в классе все члены закрыты (private).

Для того чтобы в порядке исключения дать доступ к закрытым или защищенным членам класса определенным другим классам или внешним функциям можно указать их как дружественные. Это делается с помощью ключевого слова 'friend'.

class C
{
...
friend double square(double x); //функция теперь может использовать закрытые и защищенные члены объектов класса C
friend class D; // класс D получил доступ к закрытым и защищенным членам объектов класса C
...  
};
Раздел 'public', 'private', или 'protected' класса, в котором сделаны объявления дружественности роли не играет.

Определение полей (данных) класса происходит так же как и определение любых объектов , но делается это внутри класса:
```{r,engine='Rcpp',eval=F}
//c.h
class С
{//по умолчанию все поля закрыты
public:
  double x,y; //открытые поля класса
protected:
  string description; //защищенные поля класса
private:
  double x2,y2; //закрытые поля класса
};

Доступ к полям осуществляется с помощью селекторов доступа '.' для объекта класса или '->' для указателя на объект класса.
//main.cpp
#include "c.h"
int main()
{
  С obj, pobj={&obj};
  obj.x = 0.0; // Изменение открытых полей
  obj.y = 0.0;

  pobj->x = 1.0; // Опа, снова поменяли
  pobj->y = 1.0;

  obj.x2 = 0; // Ошибка. Доступ закрыт.
}
```

Объявление и определение методов класса происходит подобно объявлению и определению функций, но только внутри класса
```{r,engine='Rcpp',eval=F}
//c.h
class С
{
public:
  double x,y; // открытые поля из предыдущего примера
  double mod(); //открытый метод класса. здесь только объявление, определение метода (тело функции) сделано отдельно, хотя можно было бы определить здесь
protected:
  string description; // метод 'mod()' имеет доступ к этому полю
private:
  double x2,y2; // и к этим полям тоже. а извне к ним доступа нет
};
 
Метод, объявленный в классе, но не определенный там же, должен быть определен отдельно. Определение вне класса дается аналогично определению функции, но добавляется оператор разрешения доступа '::', указывающий на то, что метод определен внутри класса. Имя класса указывается в определении. 

Обычно объявления классов выделяются в заголовочные файлы. Это позволяет использовать имя класса во всех файлах реализации, в которых включен данный заголовочный файл. А определение методов, которое не может дублироваться, производится единожды в файле реализации.

//c.cpp
#include "c.h" // включение заголовка для использования объявлений класса 'C'

double C::mod() // определение метода <имя класса>::<имя метода>
{
  x2 = x*x; // внутри методов класса доступ к другим полям и методам осуществляется без селектора доступа. Здесь это иллюстрирует запись значений в 'x2' и 'y2'.
  y2 = y*y;
  return( squareroot(x2+y2) );
}
 
//main.cpp
#include "c.h" // снова включение того-же заголовка для того, чтобы ниже создать объект класса 'C'
int main()
{
  С obj1, obj2;
  obj1.x = 0.0; // Изменение открытых полей
  obj1.y = 0.0;
  obj2.x = 1.0; // Изменение открытых полей
  obj2.y = 1.0;

  double abs1 = obj1.mod(); //вызов метода класса первого объекта
  double abs2 = obj2.mod(); //вызов того же метода для второго объекта

}
```
Вот в этом месте очень важно понять различие между классом и объектом. Класс определяет тип и свойства типа - данные и методы. Объект является экземпляром класса и имеет все свойства класса при этом значение этих свойств у каждого экземпляра может быть разным. У одного класса может быть множество объектов.




### Конструкторы и деструктор
Все объекты имеют определенный срок своего существования и соответственно момент создания и уничтожения. Для создания объекта могут потребоваться определенные компьютерные ресурсы такие как оперативная память для хранения полей объекта, объекты и ресурсы операционной системы, файлы, периферийные устройства или каналы коммуникаций. Выделение и инициализация всех необходимых ресурсов осуществляется в момент конструирования объекта. Освобождение ресурсов происходит при уничтожении объекта.

Для конструирования и уничтожения объектов класса есть специальные методы класса - конструкторы и деструктор. Эти методы не возвращают значений и даже не имеют типа 'void'. Имя конструктора и деструктора совпадает с именем класса, перед деструктором ставится символ '~'. Пример:

```{r,engine='Rcpp',eval=F}
// Example.h
// Объявление класса
class Example
{
public:
  Example(); // Конструктор по умолчанию - без параметров
  Example(double x, double y); // Конструктор инициализации - с параметрами
 
  Example(const Example&); // Конструктор копирования - с параметром 'const Example&'
  Example& operator=(const Example&); // Оператор копирования
 
  Example(Example&&); // Конструктор перемещения - с параметром 'Example&&'
  Example& operator=(Example&&); // Перемещение
 
  ~Example(); // Деструктор всего один и параметров у него нет

  double x,y; // открытые поля
  double mod(); // открытый (публичный) метод

protected:
  string description;
private:
  double x2,y2;
};
};

Конструкторы и деструктор определяются также как и другие методы класса. Их выделяет только отсутствие возвращаемого значения.
// Example.cpp
// Определение конструктора
Example::Example()
{
  x = 0;
  y = 0;
}
```
Если пользователь не определил конструктор самостоятельно, компилятор создаст при необходимости конструктор по умолчанию и конструктор копирования за него. Если пользователем определен хотя бы один конструктор, компилятор не вмешивается в работу программиста и автоматически не создает ничего. 

В примере показаны ситуации, в которых вызывается тот или иной конструктор:
```{r,engine='Rcpp',eval=F}
// Вызов конструктора по умолчанию
Example x, y;
Example x{};
Example *x = new Example();
 
// Вызов конструктора инициализации
Example x{1.0, 2.0};
 
// Вызов конструктора копирования
Example y{x};
Example y = x;
Example y = func();
 
// Вызов конструктора перемещения
Example z = y; ???
``` 
Деструктор вызывается при выходе объекта из области видимости или явном удалении оператором 'delete'.

Example x; // глобальный объект, деструктор вызывается при завершении программы
void f(Example e); 
int main()
{
    Example y; // деструктор вызывается при выходе из main()
    Example z = new Example();

    f(y); // 'y' передается по значению т.е. делается копия и для этого вызывается конструктор копирования
    delete z; //вызов деструктора оператором 'delete' при уничтожении динамического объекта
}

// определение функции f
void f(Example obj)
{
    // деструктор формального параметра 'obj'- копии фактического параметра 'y' - будет вызван при выходе из функции.

Example x; // деструктор будет вызван при выходе из функции 
}








### Перегрузка операторов (в форме метода класса)
```{r,engine='Rcpp',eval=F}
//c.h
class С
{
public:
  ...
  C operator+(const C&); // Оператор сложения
  ...
};
 
//c.cpp
C C::operator+(const C& с2)
{
  С res;
  res.x = x+c2.x;
  res.y = y+c2.y;
  return res;
}
 
//main.cpp
int main ()
{
    C a1,a2,a3;
    a3 = a1+a2;
    return 0;
}
```


Перегрузка операторов - арифметические операторы
```{r,engine='Rcpp',eval=F}
class Ops{
    int v;
public:
    Ops():v(0){}
    Ops(int v){this->v=v;}
    //Присваивание x = y
    Ops& operator =(const Ops &y){
        if(this != &y)
            v=y.v;
        return *this;
    }
    //Унарный плюс +x
    Ops& operator +(){return *this;}
    //Унарный минус -x
    Ops operator -(){return Ops(-v);}
    //Сложение x + y
    Ops operator +(const Ops &y){return Ops(v+y.v);}
    //Вычитание x - y
    Ops operator -(const Ops &y){return Ops(v-y.v);}
    //Умножение x * y
    Ops operator *(const Ops &y){return Ops(v*y.v);}
    //Деление x / y
    Ops operator /(const Ops &y){return Ops(v/y.v);}
    //Остаток деления x % y
    Ops operator %(const Ops &y){return Ops(v%y.v);}
    //Префиксный инкремент/декремент ++x (x=x+1)
    Ops& operator ++(){v++; return *this;}
    Ops& operator --(){v--; return *this;};
    //Постфиксный инкремент/декремент x++ (xx=x,x=x+1,xx)
    Ops operator ++(int){ Ops ret(v); v++; return ret;}
    Ops operator --(int){ Ops ret(v); v--; return ret;};
    //Оператор приведения к целому
    operator int(){return v;}
};
```


Перегрузка операторов - логические и пр. операторы

Присваивание с суммированием x += y (x = x + y): operator +=(T y);
Присваивание с вычитанием x -= y (x = x - y): operator -=(T y);
Присваивание с умножением x *= y (x = x * y): operator *=(T y);
Присваивание с делением x /= y (x = x / y): operator /=(T y);
Присваивание по модулю x %= y (x = x % y): operator %=(T y);
Присваивание с побитовым И x &= y (x = x & y): operator &=(T y);
Присваивание с побитовым ИЛИ x |= y (x = x | y): operator |=(T y);
Присваивание с побитовым исключающим ИЛИ x ^= y (x = x ^ y): operator ^=(T y);
Присваивание с побитовым сдвигом влево x <<= y (x = x << y): operator <<=(T y);
Присваивание с побитовым сдвигом вправо x >>= y (x = x >> y): operator >>=(T y);

Равенство x == y: operator ==(T y);
Неравенство x != y: operator !=(T y);
Больше x > y: operator >(T y);
Меньше x < y: operator <(T y);
Больше или равно x >= y: operator >=(T y);
Меньше или равно x <= y: operator <=(T y);

Логическое отрицание НЕ !x: operator !();
Логическое И x && y: operator &&(T y);
Логическое ИЛИ x || y: operator ||(T y);

Побитовая инверсия ~x: operator ~();
Побитовое И x & y: operator &(T y);
Побитовое ИЛИ x | y: operator |(T y);
Побитовое исключающее ИЛИ x ^ y: operator ^(T y);
Побитовый левый сдвиг x << y: operator <<(T y);
Побитовый правый сдвиг x >> y: operator >>(T y);



Перегрузка операторов - обращение и память

Обращение к элементу массива x[y]: operator [](T y);
Непрямое обращение («объект на который указывает x») *x: operator *();
Взятие адреса &x: operator &();
Обращение к члену объекта x->y: operator ->();
Обращение к объекту, на который указывает y: x->*y: operator ->*(T x);

Вызов функции x(a1, a2): operator ()(T a1, U a2, ...);
Оператор "запятая" x, y: operator ,(T y);
Преобразование типа (type) x: operator T();
Выделение памяти new type: void* operator new(size_t x);
Выделение памяти (массив) new type[n]: void* operator new[](size_t x);
Освобождение памяти delete x: operator delete(void* x);
Освобождение памяти (массив) delete[] x: operator delete[](void* x);

Не перегружаются

Обращение к члену структуры x.y
Обращение к объекту, на который указывает y x.*y
Условный оператор x ? y : c
Оператор области видимости x::y
Размер sizeof(x) sizeof(type)
Выравнивание alignof(type) Идентификация типа typeid(x) typeid(type)


```{r,engine='Rcpp',eval=F}
#include <iostream>
using namespace std;
  
#include <omp.h>
  
int main(int argc, char *argv[])
{
  #pragma omp parallel
  printf("Hello, world.\n");
 
  #pragma omp parallel for
  for (int i = 0; i < N; i++)
      ...
     
  int th_id, nthreads;
  #pragma omp parallel private(th_id) shared(nthreads)
  {
    th_id = omp_get_thread_num();
    #pragma omp critical
    {
      cout << "Hello World from thread " << th_id << '\n';
    }
    #pragma omp barrier
  
    #pragma omp master
    {
      nthreads = omp_get_num_threads();
      cout << "There are " << nthreads << " threads" << '\n';
    }
  }
  
  return 0;
}
```


```{r,engine='Rcpp',eval=F}
```


```{r,engine='Rcpp',eval=F}
```




## Объектно-ориентированное программирование
### Классы
 
```{r,engine='Rcpp',eval=F}
class T {                 // Новый тип - класс Т
private:                  // Секция доступна только для членов класса
protected:                // Также доступна для членов производных классов
public:                   // Доступна всем
 int x;                  // Член класса
 void f();               // Функция-член класса
 void g() {return;}      // Inline-функция
 void h() const;         // Не изменяет данные класса
 int operator+(int y);   // t+y вызывает t.operator+(y)
 int operator-();        // -t вызывает унарный оператор t.operator-()
 T(): x(1) {}            // Конструктор со списком инициализации
 T(const T& t): x(t.x) {}  // Конструктор копирования
 T& operator=(const T& t) {x=t.x; return *this; }  // Оператор присваивания
 ~T();                   // Деструктор
 explicit T(int a);      // Разрешить инициализацию t=T(3), запретив t=3
 operator int() const {return x;}  // Разрешить преобразование int(t)
 friend void i();        // Глобальная функция i() имеет доступ к "private"
 friend class U;         // Члены класса U имеют доступ к "private"
 static int y;           // Общие данные для всех объектов типа T
 static void l();        // Общий код для всех объектов типа Т.
                         // имеет доступ только к статическим данным
 class Z {};             // Вложенный class T::Z
 typedef int V;          // T::V означает int
};
void T::f() {             // Определение функции члена f класса T
 this->x = x;}           // this адрес собственного экземпляра (means x=x;)
int T::y = 2;             // Инициализация статического члена (обязательна)
T::l();                   // Вызов статического метода
struct T {                // В struct всё открыто по умолчанию:
                         // class T { public:
 virtual void f();       // Может быть вызвана функция производного класса
 virtual void g()=0; };  // Должна быть определена в производном
                         // классе (pure virtual)
class U: public T {};     // Производный класс U наследует все из базового T
class V: private T {};    // Унаследованные члены T становятся private
class W: public T, public U {};  // Множественное наследование
class X: public virtual T {}; // Производный от X классы содержат T
```

Все классы имеют конструктор копирования, оператор присваивания, деструктор по умолчанию, обеспечивающие соответствующую обработку каждого члена класса и базовых классов. Если класс не имеет конструкторов, существует конструктор по умолчанию, не имеющий параметров. Конструкторы, присвоения и деструкторы не наследуются.

### Наследование
```{r,engine='Rcpp',eval=F}
// Множественное наследование
#include <iostream>
using namespace std;
 
class CPolygon {
 protected:
   int width, height;
 public:
   void set_values (int a, int b)
     { width=a; height=b;}
 };
 
class COutput {
 public:
   void output (int i);
 };
 
void COutput::output (int i) {
 cout << i << endl;
 }
 
class CRectangle: public CPolygon, public COutput {
 public:
   int area ()
     { return (width * height); }
 };
 
class CTriangle: public CPolygon, public COutput {
 public:
   int area ()
     { return (width * height / 2); }
 };
 
int main () {
 CRectangle rect;
 CTriangle trgl;
 rect.set_values (4,5);
 trgl.set_values (4,5);
 rect.output (rect.area());
 trgl.output (trgl.area());
 return 0;
}
```
 
### Полиморфизм
```{r,engine='Rcpp',eval=F}
// Виртуальные функции
#include <iostream>
using namespace std;
 
class CPolygon {
 protected:
   int width, height;
 public:
   void set_values (int a, int b)
     { width=a; height=b; }
   virtual int area ()
     { return (0); }
 };
 
class CRectangle: public CPolygon {
 public:
   int area ()
     { return (width * height); }
 };
 
class CTriangle: public CPolygon {
 public:
   int area ()
     { return (width * height / 2); }
 };
 
int main () {
 CRectangle rect;
 CTriangle trgl;
 CPolygon poly;
 CPolygon * ppoly1 = &rect;
 CPolygon * ppoly2 = &trgl;
 CPolygon * ppoly3 = &poly;
 ppoly1->set_values (4,5);
 ppoly2->set_values (4,5);
 ppoly3->set_values (4,5);
 cout << ppoly1->area() << endl;
 cout << ppoly2->area() << endl;
 cout << ppoly3->area() << endl;
 return 0;
}
```

## Шаблоны
 
```{r,engine='Rcpp',eval=F}
template <class T> T f(T t);        // Определение f для любого типа
template <class T> class X {        // Класс с параметром типа T
 X(T t); };                        // Конструктор
template <class T> X<T>::X(T t) {}  // Определение конструктора
X<int> x(3);                        // Объект типа "X от int"
template <class T, class U=T, int n=0>  // Шаблон с параметрами по умолчанию
```

```{r,engine='Rcpp',eval=F}
template <typename T>
class complex {
T x,y;
public:
    complex (T x, T y):x{x},y{y}
    {
    }
};
```

## Пространства имен
 
```{r,engine='Rcpp',eval=F}
namespace N {class T {};} // T объявлено внутри пространства имен N
N::T t;                   // Использование T в пространстве имен N
using namespace N;        // Использовать пространство имен N по умолчанию
```
Пример использования пространства имен
```{r,engine='Rcpp',eval=F}
#include <iostream>
using namespace std;
 
namespace first
{
 int x = 5;
 int y = 10;
}
 
namespace second
{
 double x = 3.1416;
 double y = 2.7183;
}
 
int main () {
 using namespace first;
 cout << x << endl;
 cout << y << endl;
 cout << second::x << endl;
 cout << second::y << endl;
 return 0;
}
```


## Исключения
### Стандартные исключения
```{r,engine='Rcpp',eval=F}
#include <iostream>
#include <exception>
using namespace std;
 
class myexception: public exception
{
 virtual const char* what() const throw()
 {
   return "My exception happened";
 }
} myex;
 
int main () {
 try
 {
   throw myex;
 }
 catch (exception& e)
 {
   cout << e.what() << endl;
 }
 return 0;
}
```

## Преобразование типов
### Явное преобразование
```{r,engine='Rcpp',eval=F}
short a=2000;
int b;
b = (int) a;    // c-like
b = int (a);    // функциональная нотация
```
### Динамическое преобразование
```{r,engine='Rcpp',eval=F}
class CBase { };
class CDerived: public CBase { };
 
CBase b; CBase* pb;
CDerived d; CDerived* pd;
 
pb = dynamic_cast<CBase*>(&d);     // ok: производный к базовому
pd = dynamic_cast<CDerived*>(&b);  // ko: базовый к производному
```
### Статическое преобразование

```{r,engine='Rcpp',eval=F}
class CBase {};
class CDerived: public CBase {};
CBase * a = new CBase;
CDerived * b = static_cast<CDerived*>(a);
```
Также для явного преобразования встроенных типов
```{r,engine='Rcpp',eval=F}
double d=3.14159265;
int i = static_cast<int>(d);
```
Произвольное преобразование
```{r,engine='Rcpp',eval=F}
class A {};
class B {};
A * a = new A;
B * b = reinterpret_cast<B*>(a);
```
Преобразование константных типов
```{r,engine='Rcpp',eval=F}
// const_cast
#include <iostream>
using namespace std;
 
void print (char * str)
{
 cout << str << endl;
}
 
int main () {
 const char * c = "sample text";
 print ( const_cast<char *> (c) );
 return 0;
}
```






# Моделирование

## Детерминированные модели
### Клеточные автоматы
### Дифференциальные уравнения

## Вероятностные модели
### Нормальное распределение
### Распределение пуассона
### Экспоненциальное распределение
